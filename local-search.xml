<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2022/07/16/2022-7-13-synchronized/"/>
    <url>/2022/07/16/2022-7-13-synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="Synchrozined"><a href="#Synchrozined" class="headerlink" title="Synchrozined"></a>Synchrozined</h1><h2 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h2><blockquote><p><strong>HotSpot虚拟机</strong></p></blockquote><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207140920390.png" alt="图 15-1 64位JVM对象结构描述"></p><p>在 HotSpot虚拟机汇总，对象在内存中的存储布局可以分为三部分：对象头、实例数据、填充数据</p><ul><li>mark-word：对象标记字段，占据四个字节，用于存储一些列的标识位，比如：哈希值、轻量级锁的标记位、偏向锁标记位、分代年龄</li><li>Klass Pointer：Class对象的类型指针，jdk1.8默认开启指针压缩后为4字节，关闭指针压缩后，长度为8字节。它指向的位置是对象对应的Class对象得到内存地址</li><li>对象实际数据：包括对象的所有成员变量，大小由各个成员变量决定，比如：byte占一字节，int占4字节</li><li>对齐：最后这段空间补全并非必须，仅仅为了起到占位符的作用。由于HotSpot虚拟机的内存管理系统要求对象起始地址必须是8字节的整数倍，所以对象头正好是8字节的倍数。因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全</li></ul><p>在 <code>mark-word</code> 锁类型标记中，无锁，偏向锁，轻量锁，重量锁，以及GC标记，5种类中没法用2比特标记（2比特最终有4种组合<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>），所以无锁、偏向锁，前又占了一位偏向锁标记</p><h2 id="Synchronizedr特性"><a href="#Synchronizedr特性" class="headerlink" title="Synchronizedr特性"></a>Synchronizedr特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">10000</span>; i1++) &#123;<br>                add();<br>            &#125;<br>        &#125;);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-comment">// 等10个线程运行完毕</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(counter);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (AtomicityTest.class) &#123;<br>        counter++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在有 synchronized 时，测试结果可以成功输出 10000</p><p>synchroized 可以保证同一时间只有一个线程能拿到锁，进入代码执行</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">Thread01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!sign) &#123;<br>            i++;<br>            add(i);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">Thread02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>        &#125;<br>        sign = <span class="hljs-literal">true</span>;<br>        logger.info(<span class="hljs-string">&quot;vt.sign = true  while (!sign)&quot;</span>)<br>    &#125;);<br>    Thread01.start();<br>    Thread02.start();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的代码也是可以在睡眠三秒后退出，这也就说了 synchronized 具有可见性</p><p><strong>Why</strong></p><ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>volatile 的可见性都是通过内存屏障（Memnory Barrier）来实现的。</li><li>synchronized 靠操作系统内核互斥锁实现，相当于 JMM 中的 lock、unlock。退出代码块时刷新变量到主内存</li></ol><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p><code>as-if-serial</code>，保证不管编译器和处理器为了性能优化会如何进行指令重排序，都需要保证单线程下的运行结果的正确性。也就是常说的：<strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。</strong></p><p>双重检验锁（Double-checked Locking）的案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察上面代码可以发现，在使用 synchronized 的情况下，我们还使用了 volatile 关键字</p><p>这是因为，synchronized 的有序性，不是 volatile 的<strong>防指令重排序</strong></p><p>那如果不加 volatile 关键字可能导致的结果，就是第一个线程在初始化初始化对象，设置 instance 指向内存地址时。第二个线程进入时，有指令重排。在判断 if (instance &#x3D;&#x3D; null) 时就会有出错的可能，因为这会可能 instance 可能还没有初始化成功</p><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁🔒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentryTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentryTest</span> <span class="hljs-variable">reentry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentryTest</span>();<br>        reentry.doA();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类方法：ReentryTest.doA() ThreadId：&quot;</span> + Thread.currentThread().getId());<br>        doB();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.doA();<br>        System.out.println(<span class="hljs-string">&quot;子类方法：ReentryTest.doB() ThreadId：&quot;</span> + Thread.currentThread().getId());<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类方法：A.doA() ThreadId：&quot;</span> + Thread.currentThread().getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">子类方法：ReentryTest.doA() ThreadId：<span class="hljs-number">1</span><br>父类方法：A.doA() ThreadId：<span class="hljs-number">1</span><br>子类方法：ReentryTest.doB() ThreadId：<span class="hljs-number">1</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这段单例代码是递归调用含有 synchronized 锁的方法，从运行正常的测试结果看，并没有发生死锁。所有可以证明 synchronized 是可重入锁。</p><p>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。</p><p>之所以，是可以重入。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁</p><h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207140941334.png" alt="图 15-7 synchronized 锁升级过程"></p><p>synchronized 锁有四种交替升级的状态：无锁、偏向锁、轻量级锁和重量级，这几个状态随着竞争情况逐渐升级</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏斜锁会延缓 JIT 预热进程，所以很多性能测试中会显式地关闭偏斜锁，偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多不会真正竞争的 synchronized 块儿时，才能体现出明显改善</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），JVM虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word</p><h3 id="自选锁"><a href="#自选锁" class="headerlink" title="自选锁"></a>自选锁</h3><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><p>自旋锁的默认大小是10次，可以调整：<code>-XX：PreBlockSpin</code></p><p>如果自旋n次失败了，就会升级为重量级的锁</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3>]]></content>
    
    
    <categories>
      
      <category>Java锁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字</title>
    <link href="/2022/07/13/2022-7-13-volatile/"/>
    <url>/2022/07/13/2022-7-13-volatile/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><ul><li>保证可见性</li><li>防止指令重排</li><li>不保证原子性</li></ul><hr><ul><li>volatile 关键字会控制被修饰的变量在内存操作上主动把值刷新到主内存，JVM 会把该线程度对应的 CPU 内存设置过期，从主内存中读取最新值</li><li>volatile 如何防止指令重排也是内存屏障，volatile 的内存屏障是在镀锡操作的前后各添加一个 StroreStore 屏障，也就是四个位置，来保证排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置</li><li>volatile 关键字并不能解决<code>原子性</code>，如果需要解决原子性问题，需要使用 synchronzied 或者 lock</li></ul><h1 id="可见性案例"><a href="#可见性案例" class="headerlink" title="可见性案例"></a>可见性案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">VT</span> <span class="hljs-variable">vt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VT</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">Thread01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(vt);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">Thread02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>                &#125;<br>                vt.sign = <span class="hljs-literal">true</span>;<br>                System.out.println(<span class="hljs-string">&quot;vt.sign = true 通知 while (!sign) 结束！&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        Thread01.start();<br>        Thread02.start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VT</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!sign) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这段代码</strong>，是两个线程操作一个变量，程序想要的是当 sign 在线程 Thread01 被操作 vt.sign &#x3D; true 时，Thread02 输出 hello</p><p>但是实际上这段代码并不会输出 hello ，而是会一直处于死循环</p><h1 id="加上volatie关键字"><a href="#加上volatie关键字" class="headerlink" title="加上volatie关键字"></a>加上volatie关键字</h1><p>我们给 sign 关键字加上 volatie 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VT</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!sign) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;你坏&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加上之后 volatile 关键字是 Java 虚拟机提供的最轻量级的同步机制，他最为一个修饰符出现，用来修饰变量，但是整理不包括局部变量</p><p>在添加 volatile 关键字后，程序就符合与其的输出了 hello 。从我们对 volatile 的学习认知可以知道。volatile 关键字是 JVM 提供的最轻量级的同步机制，用来修饰变量，用来<strong>保证变量对所有线程的可见性</strong></p><p>正在修饰后可以让字段在线程见课件，那么这个属性被修改值后，可以及时的在另外的线程中做出相应的反应</p><h1 id="✨volatie怎么保证的可见性"><a href="#✨volatie怎么保证的可见性" class="headerlink" title="✨volatie怎么保证的可见性"></a>✨volatie怎么保证的可见性</h1><p>有 volatie 时的内存变化</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207131407413.png" alt="image-20220713140704279"></p><p>当我们把变量使用 volatile 修饰时，当线程01对变量进行操作时，会把变量变化的值强制刷新到主内存，当线程02获取值时，会把自己的内存里的 sign 值过期掉，之后从主内存中读取，所以添加关键字后程序如预期输出结果</p><h1 id="反编译解读可见性"><a href="#反编译解读可见性" class="headerlink" title="反编译解读可见性"></a>反编译解读可见性</h1><p>编译后的汇编指令中，有 volatile 关键字和没有 volatile 关键字，主要差别在于多了一个 lock addl $0x0,(%rsp)，也就是 lock 的前缀指令。<br>lock 指令相当于一个内存屏障，它保证如下三点：</p><ol><li>将本处理器的缓存写入内存。</li><li>重排序时不能把后面的指令重排序到内存屏障之前的位置。</li><li>如果是写入动作会导致其他处理器中对应的内存无效。</li></ol><p>那么，这里的 1、3 就是用来保证被修饰的变量，保证内存可见性。</p><p><strong>✨总结</strong></p><ul><li>volatile 关键字会控制被修饰的变量在内存操作上主动把值刷新到主内存，JVM 会把该线程度对应的 CPU 内存设置过期，从主内存中读取最新值</li><li>volatile 如何防止指令重排也是内存屏障，volatile 的内存屏障是在镀锡操作的前后各添加一个 StroreStore 屏障，也就是四个位置，来保证排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置</li><li>volatile 关键字并不能解决<code>原子性</code>，如果需要解决原子性问题，需要使用 synchronzied 或者 lock</li></ul><h1 id="不加volatile也可见"><a href="#不加volatile也可见" class="headerlink" title="不加volatile也可见"></a>不加volatile也可见</h1><p>这个地方我们是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VT</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!sign) &#123;<br>            System.out.println(<span class="hljs-string">&quot;你好&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;你坏&quot;</span>);<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>修改后去掉了 <code>volatile</code> 关键字，并在while循环中添加一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>你好<br>你好<br>你好<br>vt.sign = <span class="hljs-literal">true</span> 通知 <span class="hljs-keyword">while</span> (!sign) 结束！<br>你坏<br><br>Process finished with exit code <span class="hljs-number">0</span>   <span class="hljs-number">55555</span><br></code></pre></td></tr></table></figure><p>这个时候输出又变得正常了，也就是线程可见了</p><p>因为 print 方法加了 synchronized 关键字（当然 println 也加了，换行操作也会持有锁）</p><p>而 synchronized 方法也是能保证了该同步块中的变量的可见性的，所以下次 sign从主存中读出 true 就跳出了 while </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(String x)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        print(x);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>sychronized可以保证变量的可见性</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java锁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TreadLoacl源码分析</title>
    <link href="/2022/07/10/2022-7-10-ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/10/2022-7-10-ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="TreadLoacl源码分析"><a href="#TreadLoacl源码分析" class="headerlink" title="TreadLoacl源码分析"></a>TreadLoacl源码分析</h1><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">seckillSku</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">dateStr</span> <span class="hljs-operator">=</span> f.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-comment">// 业务流程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这样写其实是不对的，因为<code>SimpleDateFormat</code>，并不是一个线程安全的类，也就会导致我们最后格式化出来的数据并不准确</p><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><blockquote><p>这个没有了解过</p></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table; <span class="hljs-comment">// 数组存放数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>); <span class="hljs-comment">// Hash值计算下标</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从这部分源码中可以看到，<code>ThreadLocal </code>底层采用的是数组结构存储数据，同时还有哈希值计算下标，这说明它是一个散列表的数组结构</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207101818554.png" alt="image-20220710181846492"></p><ol><li>它是一个数组结构。</li><li>Entry，其实是一个弱引用实现，<code>static class Entryextends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>。这说明只要没用强引用存在，发生 GC 时就会被垃圾回收。</li><li>数据元素采用哈希散列方式进行存储，不过这里的散列使用的是<strong>斐波那契（Fibonacci）散列法</strong></li><li>另外由于这里不同于 HashMap 的数据结构，发生哈希碰撞不会存成链表或红黑树，而是使用拉链法进行存储。也就是同一个下标位置发生冲突时，则+1 向后寻址，直到找到空位置或垃圾回收位置进行存储</li></ol><h1 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h1><p><code>ThreadLocal </code>是基于数组结构的拉链法存储的，那就一定会有哈希的计算。但我们翻阅源码后，发现这个哈希计算与 HashMap 中的散列求数组下标计算的哈希方式不一样</p><h2 id="神秘的数字0x61c88647"><a href="#神秘的数字0x61c88647" class="headerlink" title="神秘的数字0x61c88647"></a>神秘的数字0x61c88647</h2><blockquote><p>tip：斐波那契（Fibonacci）散列法是根据这个来完成的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the next hash code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>数字 0x61c88647</strong>：这个其实是黄金分割点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 黄金分割点：(√5 - 1) / 2 = 0.6180339887 1.618:1 == 1:0.618</span><br>System.out.println(BigDecimal.valueOf(Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>) * <span class="hljs-number">0.6180339887</span>).intValue());<br><span class="hljs-comment">//-1640531527</span><br></code></pre></td></tr></table></figure><ul><li>学过数学都应该知道，黄金分割点是，(√5 - 1) &#x2F; 2，取 10 位近似0.6180339887</li><li>之后用 2 ^ 32 * 0.6180339887，得到的结果是：-1640531527，也就是 16 进制的，0x61c88647。这个数呢也就是这么来的</li></ul><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;()<br></code></pre></td></tr></table></figure><p>初始化的过程也很简单，可以按照自己需要的泛型进行设置。但在 ThreadLocal 的源码中有一点非常重要 ，就是获取 threadLocal 的哈希值的获取，<code>threadLocalHashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode(); <span class="hljs-comment">// 获取hash值</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><p>如源码中，只要实例化一个 <code>ThreadLocal </code>，就会获取一个相应的哈希值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_threadLocalHashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        ThreadLocal&lt;Object&gt; objectThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> objectThreadLocal.getClass().getDeclaredField(<span class="hljs-string">&quot;threadLocalHashCode&quot;</span>);<br>        threadLocalHashCode.setAccessible(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;objectThreadLocal：&quot;</span> + threadLocalHashCode.get(objectThreadLocal));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">objectThreadLocal：1253254570<br>objectThreadLocal：-1401181199<br>objectThreadLocal：239350328<br>objectThreadLocal：1879881855<br>objectThreadLocal：-774553914<br></code></pre></td></tr></table></figure><p>这个值的获取，也就是计算 <code>ThreadLocalMap</code>，存储数据时，ThreadLocal 的数组下标。只要是这同一个对象，在 set、get 时，就可以设置和获取对应的值</p><h2 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h2><p>这个可以看图去理解</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207101825235.png" alt="image-20220710182524106"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table; <span class="hljs-comment">// Entry 是一个弱引用对象的实现类</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>); <span class="hljs-comment">// 计算下标</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123; <span class="hljs-comment">// 循环判断元素是否存在</span><br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            replaceStaleEntry(key, value, i); <span class="hljs-comment">//   </span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value); <span class="hljs-comment">// 存在直接设置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>key.threadLocalHashCode &amp; (len-1);</code>，斐波那契散列，计算数组下标</p></li><li><p><code>Entry</code>，是一个弱引用对象的实现类，<code>static class Entry extendsWeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，所以在没有外部强引用下，会发生<code>GC</code>，删除 <code>key</code></p></li><li><p>for 循环判断元素是否存在，当前下标不存在元素时，直接设置元素 <code>tab[i] =new Entry(key, value); </code></p></li><li><p>如果元素存在，则会判断是否 key 值相等 <code>if (k == key)</code>，相等则更新值</p></li><li><p>如果不相等，就到了我们的 <code>replaceStaleEntry</code>，也就是上面的探测式清理过期元素</p></li></ol><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br></code></pre></td></tr></table></figure><p><strong>上面的代码就是判断是否扩容</strong></p><ul><li>首先，进行启发式清理<strong>cleanSomeSlots</strong>，把过期元素清理掉，看空间是否够</li><li>之后，判断<code> sz &gt;= threshold</code>，其中 <code>threshold = len * 2 / 3</code>，也就是说数组中天填充的元素，大于 <code>len * 2 / 3</code>，就需要扩容了。</li><li>最后，就是我们要分析的重点，<code>rehash();</code>，扩容重新计算元素位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>    expungeStaleEntries();<br><br>    <span class="hljs-comment">// Use lower threshold for doubling to avoid hysteresis</span><br>    <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span>)<br>        resize();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这部分是主要是探测式清理过期元素，以及判断清理后是否满足扩容条件， <code>size &gt;= threshold * 3/4</code></li><li>满足后执行扩容操作，其实扩容完的核心操作就是重新计算哈希值，把元素填充到新的数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>首先把数组长度扩容到原来的 2 倍，<code>oldLen * 2</code>，实例化新数组</p></li><li><p>遍历 for，所有的旧数组中的元素，重新放到新数组中</p></li><li><p>在放置数组的过程中，如果发生哈希碰撞，则链式法顺延</p></li><li><p>同时这还有检测 key 值的操作 <code>if (k == null)</code>，方便 GC</p></li></ol><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207101917480.png" alt="image-20220710191734400"></p><p>按照不同的数据元素存储情况，基本包括如下情况；</p><ol><li>直接定位到，没有哈希冲突，直接返回元素即可。</li><li>没有直接定位到了，key 不同，需要拉链式寻找。</li><li>没有直接定位到了，key 不同，拉链式寻找，遇到 GC 清理元素，需要探测式清理，再寻找元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="元素清理"><a href="#元素清理" class="headerlink" title="元素清理"></a>元素清理</h2><p><strong>探测式清理</strong></p><p>探测式清理，是以当前遇到的 GC 元素开始，向后不断的清理。直到遇到 null为止，才停止 rehash 计算 Rehash until we encounter null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expungeStaleEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> staleSlot)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-comment">// expunge entry at staleSlot</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-literal">null</span>;<br>    size--;<br><br>    <span class="hljs-comment">// Rehash until we encounter null</span><br>    Entry e;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = nextIndex(staleSlot, len);<br>         (e = tab[i]) != <span class="hljs-literal">null</span>;<br>         i = nextIndex(i, len)) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>            e.value = <span class="hljs-literal">null</span>;<br>            tab[i] = <span class="hljs-literal">null</span>;<br>            size--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (h != i) &#123;<br>                tab[i] = <span class="hljs-literal">null</span>;<br><br>                <span class="hljs-comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span><br>                <span class="hljs-comment">// null because multiple entries could have been stale.</span><br>                <span class="hljs-keyword">while</span> (tab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, len);<br>                tab[h] = e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>探测式清理在获取元素中使用到； new ThreadLocal&lt;&gt;().get() -&gt;  map.getEntry(this) -&gt; getEntryAfterMiss(key, i, e) -&gt; expungeStaleEntry(i)</p><p><strong>启发式清理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Heuristically scan some cells looking for stale entries.</span><br><span class="hljs-comment"> * This is invoked when either a new element is added, or</span><br><span class="hljs-comment"> * another stale one has been expunged. It performs a</span><br><span class="hljs-comment"> * logarithmic number of scans, as a balance between no</span><br><span class="hljs-comment"> * scanning (fast but retains garbage) and a number of scans</span><br><span class="hljs-comment"> * proportional to number of elements, that would find all</span><br><span class="hljs-comment"> * garbage but would cause some insertions to take O(n) time.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i a position known NOT to hold a stale entry. The</span><br><span class="hljs-comment"> * scan starts at the element after i.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n scan control: &#123;<span class="hljs-doctag">@code</span> log2(n)&#125; cells are scanned,</span><br><span class="hljs-comment"> * unless a stale entry is found, in which case</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> log2(table.length)-1&#125; additional cells are scanned.</span><br><span class="hljs-comment"> * When called from insertions, this parameter is the number</span><br><span class="hljs-comment"> * of elements, but when from replaceStaleEntry, it is the</span><br><span class="hljs-comment"> * table length. (Note: all this could be changed to be either</span><br><span class="hljs-comment"> * more or less aggressive by weighting n instead of just</span><br><span class="hljs-comment"> * using straight log n. But this version is simple, fast, and</span><br><span class="hljs-comment"> * seems to work well.)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if any stale entries have been removed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cleanSomeSlots</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-keyword">do</span> &#123;<br>        i = nextIndex(i, len);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>) &#123; <br>            n = len;<br>            removed = <span class="hljs-literal">true</span>;<br>            i = expungeStaleEntry(i);<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> ( (n &gt;&gt;&gt;= <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><p>启发式清理，有这么一段注释，大概意思是；试探的扫描一些单元格，寻找过期元素，也就是被垃圾回收的元素。当添加新元素或删除另一个过时元素时，将调<br>用此函数。它执行对数扫描次数，作为不扫描（快速但保留垃圾）和与元素数量成比例的扫描次数之间的平衡，这将找到所有垃圾，但会导致一些插入花费 O（n）时间</p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>TreadLoacl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring复习笔记</title>
    <link href="/2022/07/10/2022-7-10-%20Spring%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/10/2022-7-10-%20Spring%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring复习笔记"><a href="#Spring复习笔记" class="headerlink" title="Spring复习笔记"></a>Spring复习笔记</h1><p>Spring 这个框架是用于整合其它框架所使用的。官网地址：<a href="https://spring.io/">https://spring.io/</a></p><p>Spring 框架的核心是 DI&#x2F;IoC，AOP，事务管理。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111814592.png" alt="image-20220711181439482"></p><p>Spring中所有对象都是 Bean 对象。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-依赖注入"><a href="#1-依赖注入" class="headerlink" title="1. 依赖注入"></a>1. 依赖注入</h2><p>依赖注入（Dependency Injection, DI），它在 Spring 中是通过工厂及配置文件来实现，目的是为了给对象的成员进行赋值。</p><p>在不使用依赖注入时是这样给成员对象赋值的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.setId(<span class="hljs-number">1</span>);<br>user.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br></code></pre></td></tr></table></figure><p>也就是说是先创建对象，然后调用对象成员的 set 方法来给成员对象赋值。</p><p>如果使用依赖注入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xianoupeng.entity.User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用依赖注入有什么好处？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 解耦，以前是我们手动new对象，这叫硬编码。使用了配置方式后，就不用我们硬编码了，创建对象的时机是交给Spring框架来完成。<br><span class="hljs-bullet">2.</span> 灵活<br></code></pre></td></tr></table></figure><h2 id="2-控制反转"><a href="#2-控制反转" class="headerlink" title="2. 控制反转"></a>2. 控制反转</h2><p>控制反转（Inversion of Control, IoC），它是核心，指的是对象成员变量的赋值的控制权由原来我们自己创建现在变为交给 Spring 来创建。</p><h2 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3. 常用注解"></a>3. 常用注解</h2><h3 id="3-1-Configuration"><a href="#3-1-Configuration" class="headerlink" title="3.1 @Configuration"></a>3.1 @Configuration</h3><p>它是标注在类上的，被它标注的类就是一个配置类，它的使用就相当于 applicationContext.xml 文件的作用。</p><h3 id="3-2-Component"><a href="#3-2-Component" class="headerlink" title="3.2 @Component"></a>3.2 @Component</h3><p>这个注解是让 Spring 容器在加载时自动会添加到容器里面的注解。它也是标注在类上的。它在 Spring 容器中就相当于一个 Bean 标签。</p><h3 id="3-3-Reponstory"><a href="#3-3-Reponstory" class="headerlink" title="3.3 @Reponstory"></a>3.3 @Reponstory</h3><p>这个注解的作用也 @Component 这个注解的作用和功能一样。但从语义层面来说，这个注解是用于数据访问层，而 @Component 常用于层次不态明确或没有层次的地方。</p><h3 id="3-4-Service"><a href="#3-4-Service" class="headerlink" title="3.4 @Service"></a>3.4 @Service</h3><p>这个注解的作用也 @Component 这个注解的作用和功能一样。但从语义层面来说，这个注解是用于业务逻辑层。</p><h3 id="3-5-Controller"><a href="#3-5-Controller" class="headerlink" title="3.5 @Controller"></a>3.5 @Controller</h3><p>这个注解的作用也 @Component 这个注解的作用和功能一样。但从语义层面来说，这个注解是用于访问控制层。</p><h3 id="3-6-Bean"><a href="#3-6-Bean" class="headerlink" title="3.6 @Bean"></a>3.6 @Bean</h3><p>它是标注在一个方法上的，这个注解可以给它一个 name 属性，用于给这个 Bean 对象取一个唯一的名称，便于调用。如果没有给定 name 属性，那么被这个注解所标注的方法所对应的名称就是方法名称。</p><h3 id="3-7-Autowired"><a href="#3-7-Autowired" class="headerlink" title="3.7 @Autowired"></a>3.7 @Autowired</h3><p>这个注解可以添加到成员属性、方法参数、构造方法上。它的作用是把被标注的对象进行自动注入（装配）。被它注解的对象默认是按照类型来自动装配。如果希望按照名称来进行自动装配，那么要接合 @Qualifier 注解一起使用。</p><h3 id="3-8-Qualifier"><a href="#3-8-Qualifier" class="headerlink" title="3.8 @Qualifier"></a>3.8 @Qualifier</h3><p>它的作用是配合 @Autowired 注解来按名称进行装配，它不能独立使用。如果希望能够独立使用，则只能放到参数列表中。</p><h3 id="3-9-Value"><a href="#3-9-Value" class="headerlink" title="3.9 @Value"></a>3.9 @Value</h3><p>这个注解的作用是对基本数据类型和字符串类型进行注入值。</p><h3 id="3-10-ComponentScan"><a href="#3-10-ComponentScan" class="headerlink" title="3.10 @ComponentScan"></a>3.10 @ComponentScan</h3><p>这个注解是用于类上的，它的作用是对指定名路径进行扫描。</p><h3 id="3-11-PropertySource"><a href="#3-11-PropertySource" class="headerlink" title="3.11 @PropertySource"></a>3.11 @PropertySource</h3><p>这个注解的作用加载 .properties 文件中的配置。</p><p>定义 jdbc.properties 配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>定义配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcConfig</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>这个注解是用于标注在类上的，作用是导入其它的配置类，它是可以一次导入多个配置类。</p><p>配置类 A：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigA</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>配置类 B：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigB</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>主配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(&#123;ConfigA.class, ConfigB.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configure</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1. 创建工程"></a>1. 创建工程</h2><p> <img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111814386.png" alt="image-20220711181430312"></p><h2 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2. 添加依赖"></a>2. 添加依赖</h2><p>在 pom.xml 文件中添加如下的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-编写配置文件"><a href="#3-编写配置文件" class="headerlink" title="3. 编写配置文件"></a>3. 编写配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xianoupeng.entity.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘备&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.xianoupeng.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-编写实现类"><a href="#4-编写实现类" class="headerlink" title="4. 编写实现类"></a>4. 编写实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(User user)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(User user)</span> &#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExtendWith(SpringExtension.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringTest</span> &#123;<br>    <span class="hljs-comment">//@Autowired</span><br>    <span class="hljs-comment">//private ApplicationContext context;</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);</span><br><br>        <span class="hljs-comment">//UserDao userDao = context.getBean(UserDao.class);</span><br>        userDao.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>().setId(<span class="hljs-number">100</span>).setName(<span class="hljs-string">&quot;张飞&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="核心容器类"><a href="#核心容器类" class="headerlink" title="核心容器类"></a>核心容器类</h1><h2 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h2><p>Spring中Bean的创建是典型的工厂模式，一系列的 Bean 工厂，即 IoC容器，为开发者提供了管理对象之间的依赖关系。</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111814409.png" alt="image-20220711181420309"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">FACTORY_BEAN_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(String var1, Class&lt;T&gt; var2)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String var1, Object... var2)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; var1)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; var1, Object... var2)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="hljs-title function_">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; var1)</span>;<br><br>    &lt;T&gt; ObjectProvider&lt;T&gt; <span class="hljs-title function_">getBeanProvider</span><span class="hljs-params">(ResolvableType var1)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBean</span><span class="hljs-params">(String var1)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototype</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String var1, ResolvableType var2)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String var1, Class&lt;?&gt; var2)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-meta">@Nullable</span><br>    Class&lt;?&gt; getType(String var1) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-meta">@Nullable</span><br>    Class&lt;?&gt; getType(String var1, <span class="hljs-type">boolean</span> var2) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    String[] getAliases(String var1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-BeanDefinition"><a href="#2-BeanDefinition" class="headerlink" title="2. BeanDefinition"></a>2. BeanDefinition</h2><p>它是 Spring IoC 容器管理我们定义的各种 Bean 对象及其相互之间的关系。</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111814787.png" alt="image-20220711181408682"></p><h2 id="3-BeanDefinitionReader"><a href="#3-BeanDefinitionReader" class="headerlink" title="3. BeanDefinitionReader"></a>3. BeanDefinitionReader</h2><p>Bean 的解析过程非常复杂，功能被分解得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能发生的变化。</p><h1 id="IoC源码"><a href="#IoC源码" class="headerlink" title="IoC源码"></a>IoC源码</h1><p>ApplicatoinContext 允许下下文嵌套，通过保持父上下文就可以维持一个上下文关系。</p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>通过 ClassPathXmlApplicationContext 请求配置文件的地方来进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring.xml&quot;</span>);<br></code></pre></td></tr></table></figure><p>先看这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;configLocation&#125;, <span class="hljs-literal">true</span>, (ApplicationContext)<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实调用的是本类中的另一个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String[] configLocations, <span class="hljs-type">boolean</span> refresh, <span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-built_in">super</span>(parent);<br>    <span class="hljs-built_in">this</span>.setConfigLocations(configLocations);<br>    <span class="hljs-keyword">if</span> (refresh) &#123;<br>        <span class="hljs-built_in">this</span>.refresh();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个构造器中，最关键的代码是 <code>this.refresh();</code></p><p>点击这个方法，会进入到 AbstractApplicaitonContext 类中的 refresh() 方法中。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//....省略</span><br>    <br>    <span class="hljs-comment">// 加载资源并进行解析</span><br>    <span class="hljs-built_in">this</span>.resourcePatternResolver = <span class="hljs-built_in">this</span>.getResourcePatternResolver();<br>&#125;<br></code></pre></td></tr></table></figure><p>点击这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ResourcePatternResolver <span class="hljs-title function_">getResourcePatternResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMatchingResourcePatternResolver</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>点击这个方法，进入 PathMatchingResourcePatternResolver 类中的有参构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">PathMatchingResourcePatternResolver</span><span class="hljs-params">(ResourceLoader resourceLoader)</span> &#123;<br>    Assert.notNull(resourceLoader, <span class="hljs-string">&quot;ResourceLoader must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个构造器中设置了 Spring 资源加载器。</p><p>设置了容器的资源加载器后，我们就要进入到 ClassPathXmlApplicationContext 类中的 setConfigLocations() 方法中，通过调用其父类 AbstractRefreshableConfigApplicationContext 的方法进行 Bean 配置信息的定位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfigLocations</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String... locations)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locations != <span class="hljs-literal">null</span>) &#123;<br>        Assert.noNullElements(locations, <span class="hljs-string">&quot;Config locations must not be null&quot;</span>);<br>        <span class="hljs-built_in">this</span>.configLocations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[locations.length];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; locations.length; ++i) &#123;<br>            <span class="hljs-built_in">this</span>.configLocations[i] = <span class="hljs-built_in">this</span>.resolvePath(locations[i]).trim();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.configLocations = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>Spring 容器对 Bean 配置资源的载入是从 refresh() 方法开始的。它是一个模板方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">contextRefresh</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.refresh&quot;</span>);<br>        <span class="hljs-comment">// 1. 调用容器准备刷新的方法，获取容器的当前时间，同时给容器设置同步标识</span><br>        <span class="hljs-built_in">this</span>.prepareRefresh();<br>        <span class="hljs-comment">// 2. 告诉子类启动 refreshBeanFactory() 方法，Bean 定义资源文件的加载从它的子类的 refreshBeanFactory() 启动</span><br>        <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.obtainFreshBeanFactory();<br>        <span class="hljs-comment">// 3. 为 BeanFactory 配置容器特性，例如类加载器、事件处理器等</span><br>        <span class="hljs-built_in">this</span>.prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 4. 为容器的某些子类指定特殊的 post 事件处理器</span><br>            <span class="hljs-built_in">this</span>.postProcessBeanFactory(beanFactory);<br>            <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanPostProcess</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.beans.post-process&quot;</span>);<br>            <span class="hljs-comment">// 5. 调用所有注册的 BeanFactoryPostProcessor 的 Bean</span><br>            <span class="hljs-built_in">this</span>.invokeBeanFactoryPostProcessors(beanFactory);<br>            <span class="hljs-comment">// 6. 为 BeanPost 注册 Post 事件处理器</span><br>            <span class="hljs-built_in">this</span>.registerBeanPostProcessors(beanFactory);<br>            beanPostProcess.end();<br>            <span class="hljs-comment">// 7. 初始化信息源，如国际化相关</span><br>            <span class="hljs-built_in">this</span>.initMessageSource();<br>            <span class="hljs-comment">// 8. 初始化容器事件传播器</span><br>            <span class="hljs-built_in">this</span>.initApplicationEventMulticaster();<br>            <span class="hljs-comment">// 9. 调用子类的某些特殊 Bean 的初始化方法</span><br>            <span class="hljs-built_in">this</span>.onRefresh();<br>            <span class="hljs-comment">// 10. 为事件传播器注册事件监听器</span><br>            <span class="hljs-built_in">this</span>.registerListeners();<br>            <span class="hljs-comment">// 11. 初始化所有剩余的单例 Bean</span><br>            <span class="hljs-built_in">this</span>.finishBeanFactoryInitialization(beanFactory);<br>            <span class="hljs-comment">// 12. 初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br>            <span class="hljs-built_in">this</span>.finishRefresh();<br>        &#125; <span class="hljs-keyword">catch</span> (BeansException var10) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isWarnEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var10);<br>            &#125;<br><span class="hljs-comment">// 13. 销毁已创建的 Bean</span><br>            <span class="hljs-built_in">this</span>.destroyBeans();<br>            <span class="hljs-comment">// 14. 取消刷新操作，重置容器的同步标识</span><br>            <span class="hljs-built_in">this</span>.cancelRefresh(var10);<br>            <span class="hljs-keyword">throw</span> var10;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 15. 重置公共缓存</span><br>            <span class="hljs-built_in">this</span>.resetCommonCaches();<br>            contextRefresh.end();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法，就完全包含了 Bean 的完整生命周期方法。</p><p>点击 <code>obtainFreshBeanFactory()</code> 这个方法，进入 AbstractApplicationContext 类中的 obtainFreshBeanFactory() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title function_">obtainFreshBeanFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 使用了委派模式，父类定义了抽象的 refreshBeanFactory() 方法，具体的实现子类来完成。</span><br>    <span class="hljs-built_in">this</span>.refreshBeanFactory();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getBeanFactory();<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 refreshBeanFactory() 方法，进入 AbstractRefreshableApplicationContext 类中的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">// 如果已经有容器，则销毁容器中的 Bean，然后关闭容器</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasBeanFactory()) &#123;<br>        <span class="hljs-built_in">this</span>.destroyBeans();<br>        <span class="hljs-built_in">this</span>.closeBeanFactory();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建 IoC 容器</span><br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createBeanFactory();<br>        beanFactory.setSerializationId(<span class="hljs-built_in">this</span>.getId());<br>        <span class="hljs-comment">// 对 IoC 容器进行定制化，如设置启动参数、开启注解的自动装配等。</span><br>        <span class="hljs-built_in">this</span>.customizeBeanFactory(beanFactory);<br>        <span class="hljs-comment">// 调用 Bean 定义的方法，也是使用委派模式，当类中定义了抽象的 loadBeanDefinitions() 方法时，调用子类容器实现</span><br>        <span class="hljs-built_in">this</span>.loadBeanDefinitions(beanFactory);<br>        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException var2) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextException</span>(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + <span class="hljs-built_in">this</span>.getDisplayName(), var2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="载入配置路径"><a href="#载入配置路径" class="headerlink" title="载入配置路径"></a>载入配置路径</h2><p>点击 <code>loadBeanDefinitions()</code> 这个方法并进入 AbstractXmlApplicationContext 类中的 loadBeanDefinitions() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException &#123;<br>    <span class="hljs-comment">// 创建 XmlBeanDefinitionReader 对象，用于读取 Bean 信息，并通过回调设置到容器中，容器使用该读取器读取 Bean 配置资源</span><br>    <span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">beanDefinitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(beanFactory);<br>    <span class="hljs-comment">// 为 Bean 对象设置资源加载器</span><br>    beanDefinitionReader.setEnvironment(<span class="hljs-built_in">this</span>.getEnvironment());<br>    beanDefinitionReader.setResourceLoader(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// 为 Bean 读取器设置 SAX xml 解析器</span><br>    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEntityResolver</span>(<span class="hljs-built_in">this</span>));<br>    <span class="hljs-comment">// 为 Bean 读取器读取 Bean 定义的 xml 资源文件时启动 xml 校验机制</span><br>    <span class="hljs-built_in">this</span>.initBeanDefinitionReader(beanDefinitionReader);<br>    <span class="hljs-comment">// Bean 读取器真正实现加载的方法</span><br>    <span class="hljs-built_in">this</span>.loadBeanDefinitions(beanDefinitionReader);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次点击 <code>loadBeanDefinitions()</code> 进入本类中的另一个方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException &#123;<br>    <span class="hljs-comment">// 读取 Bean 配置资源定位</span><br>    Resource[] configResources = <span class="hljs-built_in">this</span>.getConfigResources();<br>    <span class="hljs-keyword">if</span> (configResources != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// xml Bean 读取器调用父类 AbstractBeanDefinitionReader 中读取定位的 Bean 资源方法</span><br>        reader.loadBeanDefinitions(configResources);<br>    &#125;<br><span class="hljs-comment">// 如果子类中获取的 Bean 配置资源为空，则获取 AbstractRefreshableConfigApplicationContext 构造器方法中setConfigLocations() 方法配置的资源 </span><br>    String[] configLocations = <span class="hljs-built_in">this</span>.getConfigLocations();<br>    <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// xml Bean 读取器调用其父类中的 AbstractBeanDefinitionReader 中读取定位的 Bean 资源方法</span><br>        reader.loadBeanDefinitions(configLocations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过查看上面的源码可以发现，不管在 Bean 是否读取到 Bean 定位资源，最终都会执行父类 AbstractBeanDefinitionReader 中的 loadBeanDefinitions() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    Assert.notNull(locations, <span class="hljs-string">&quot;Location array must not be null&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (String location : locations) &#123;<br>        count += loadBeanDefinitions(location);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中统计资源的个数，同时也再次调用了 <code>loadBeanDefinitions()</code> 方法，点击后进入到本类中的同名方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-keyword">return</span> loadBeanDefinitions(location, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次进入 <code>loadBeanDefinitions()</code> 方法，进入本类中另一个同名的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String location, <span class="hljs-meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">// 获取在 IoC 容器初始化过程中设置的资源加载器</span><br>    <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> getResourceLoader();<br>    <span class="hljs-keyword">if</span> (resourceLoader == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>            <span class="hljs-string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="hljs-string">&quot;]: no ResourceLoader available&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (resourceLoader <span class="hljs-keyword">instanceof</span> ResourcePatternResolver) &#123;<br>        <span class="hljs-comment">// 资源模式匹配</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将指定位置的 Bean 配置信息解析为 Spring IoC 容器封装的资源，加载多个指定的 Bean 配置信息</span><br>            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>            <span class="hljs-comment">// 使用委派模式，调用其子类的 XmlBeanDefinitionReader 的方法，实现加载功能</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resources);<br>            <br>            <span class="hljs-comment">//......省略</span><br>            <br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>        <span class="hljs-comment">//.....省略</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将指定位置的 Bean 配置信息解析为 Spring IoC 容器封装的资源，加载单个指定位置的 Bean 配置信息</span><br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> resourceLoader.getResource(location);<br>        <span class="hljs-comment">// 使用委派模式，调用其子类的 XmlBeanDefinitionReader 的方法，实现加载功能</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resource);<br>        <br>        <span class="hljs-comment">//......省略</span><br>        <br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次进入 <code>loadBeanDefinitions()</code>，进入 XmlBeanDefinitionReader 类中的 loadBeanDefinitions()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedResource</span>(resource));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中又调用了本类中的 <code>loadBeanDefinitions()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">//.....省略</span><br><br>    <span class="hljs-comment">// 获取 Resource 对象 转换为 XML 文件流对象</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> encodedResource.getResource().getInputStream()) &#123;<br>        <span class="hljs-comment">// 将流转换成 InputSource</span><br>        <span class="hljs-type">InputSource</span> <span class="hljs-variable">inputSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(inputStream);<br>        <span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-literal">null</span>) &#123;<br>            inputSource.setEncoding(encodedResource.getEncoding());<br>        &#125;<br>        <span class="hljs-comment">// 加载</span><br>        <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>    &#125;<br>    <span class="hljs-comment">//.....省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>点击 <code>doLoadBeanDefinitions()</code> 方法并进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span><br>    <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 将 Resource 转成 Document 对象</span><br>        <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> doLoadDocument(inputSource, resource);<br>        <span class="hljs-comment">// 解析 Document 对象</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> registerBeanDefinitions(doc, resource);<br>        <br>        <span class="hljs-comment">//....省略</span><br>        <br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//......省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进入 <code>registerBeanDefinitions()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-comment">// 创建 Document 解析器进行解析</span><br>    <span class="hljs-type">BeanDefinitionDocumentReader</span> <span class="hljs-variable">documentReader</span> <span class="hljs-operator">=</span> createBeanDefinitionDocumentReader();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">countBefore</span> <span class="hljs-operator">=</span> getRegistry().getBeanDefinitionCount();<br>    <span class="hljs-comment">// 用 Document解析器进行解析</span><br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h2><p>进入 <code>registerBeanDefinitions()</code>这个方法会进入 BeanDefinitionDocumentReader 接口类中的 registerBeanDefinitions 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionDocumentReader</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span><br><span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后找到这个接口的子类 BeanDefinitionDocumentReader 对应的方法并进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> &#123;<br>    <span class="hljs-built_in">this</span>.readerContext = readerContext;<br>    <span class="hljs-comment">// 解析 XML 中配置的信息，并存入到 BeanDefinition对象中</span><br>    doRegisterBeanDefinitions(doc.getDocumentElement());<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 <code>doRegisterBeanDefinitions()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> &#123;<br><span class="hljs-comment">// ....省略</span><br><br>    <span class="hljs-comment">// 处理（解析）XML配置文件之前的操作</span><br>preProcessXml(root);<br><span class="hljs-comment">// 解析</span><br>parseBeanDefinitions(root, <span class="hljs-built_in">this</span>.delegate);<br>postProcessXml(root);<br><br><span class="hljs-built_in">this</span>.delegate = parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中最核心的就是 <code>parseBeanDefinitions()</code> 方法，进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> root.getChildNodes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;<br>                <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>                    <span class="hljs-comment">// 默认标签解析</span><br>                    parseDefaultElement(ele, delegate);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 自定义标签解析</span><br>                    delegate.parseCustomElement(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        delegate.parseCustomElement(root);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 <code>parseDefaultElement()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">// import 标签</span><br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>        importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-comment">// alias 标签</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>        processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-comment">// bean 标签</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>        processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-comment">// beans 标签</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>        <span class="hljs-comment">// recurse</span><br>        doRegisterBeanDefinitions(ele);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们以解析 <code>&lt;bean&gt;</code> 标签为例，进入 <code>processBeanDefinition()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br><span class="hljs-comment">// 将 Element 封装成 BeanDefinition</span><br><span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">bdHolder</span> <span class="hljs-operator">=</span> delegate.parseBeanDefinitionElement(ele);<br><span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-literal">null</span>) &#123;<br>bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 向Spring IoC 容器注册解析得到的 Bean 定义，这是 Bean 定义向 IoC 容器注册入口</span><br>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>&#125;<br><span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>getReaderContext().error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +<br>bdHolder.getBeanName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);<br>&#125;<br><span class="hljs-comment">// 在完成向 Spring IoC 容器注册解析得到的 Bean 定义之后，发送注册事件</span><br>getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComponentDefinition</span>(bdHolder));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>点击 <code>parseBeanDefinitionElement()</code> 方法并进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title function_">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele)</span> &#123;<br>    <span class="hljs-keyword">return</span> parseBeanDefinitionElement(ele, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再点击进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title function_">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;<br>    <span class="hljs-comment">// 获取&lt;bean&gt;元素中的 id 属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ele.getAttribute(ID_ATTRIBUTE);<br>    <span class="hljs-comment">// 获取&lt;bean&gt;元素中的 name 属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameAttr</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<br><span class="hljs-comment">// 获取&lt;bean&gt;元素中的 alias 属性</span><br>    List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 将 &lt;bean&gt; 元素中的所有 name 属性值存放到别名中</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>        aliases.addAll(Arrays.asList(nameArr));<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> id;<br>    <span class="hljs-comment">// 如果 &lt;bean&gt; 元素中没有配置 id 属性，将别名中的第一个值赋给 beanName</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;<br>        beanName = aliases.remove(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +<br>                         <span class="hljs-string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="hljs-string">&quot; as aliases&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 检查 &lt;bean&gt; 元素所配置的 id 或者 name 的唯一性</span><br>    <span class="hljs-comment">// containingBean 标识 &lt;bean&gt; 元素中是否包含子 &lt;bean&gt; 元素</span><br>    <span class="hljs-keyword">if</span> (containingBean == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 检查 &lt;bean&gt; 元素所配置的 id、name 或者别名是否重复</span><br>        checkNameUniqueness(beanName, aliases, ele);<br>    &#125;<br><br>    <span class="hljs-comment">// 详细对 &lt;bean&gt; 元素中配置的 Bean 定义进行解析</span><br>    <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);<br><br>    <span class="hljs-keyword">if</span> (beanDefinition != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (containingBean != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果 &lt;bean&gt; 元素中没有配置 id、name 或者别名，且没有包含子元素&lt;bean&gt; 元素，</span><br>                    <span class="hljs-comment">// 则为解析的 Bean 生成一个唯一 beanName 并注册</span><br>                    beanName = BeanDefinitionReaderUtils.generateBeanName(<br>                        beanDefinition, <span class="hljs-built_in">this</span>.readerContext.getRegistry(), <span class="hljs-literal">true</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果 &lt;bean&gt; 元素中没有配置 id、name 或者别名，且包含子元素&lt;bean&gt; 元素，</span><br>                    <span class="hljs-comment">// 则将解析的 Bean 使用别名向 IoC 容器注册</span><br>                    beanName = <span class="hljs-built_in">this</span>.readerContext.generateBeanName(beanDefinition);<br>                    <span class="hljs-comment">// 为解析的 Bean 使用别名注册时，为了向后兼容 Spring 1.2/2.0，给别名添加类名后缀</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">beanClassName</span> <span class="hljs-operator">=</span> beanDefinition.getBeanClassName();<br>                    <span class="hljs-keyword">if</span> (beanClassName != <span class="hljs-literal">null</span> &amp;&amp;<br>                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br>                        !<span class="hljs-built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;<br>                        aliases.add(beanClassName);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//....省略</span><br>            &#125;<br>            <span class="hljs-comment">//....省略</span><br>        &#125;<br>        String[] aliasesArray = StringUtils.toStringArray(aliases);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);<br>    &#125;<br><span class="hljs-comment">// 当解析出错时，返回 null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="DI源码"><a href="#DI源码" class="headerlink" title="DI源码"></a>DI源码</h1><h2 id="依赖注入发生时间"><a href="#依赖注入发生时间" class="headerlink" title="依赖注入发生时间"></a>依赖注入发生时间</h2><p>当 Spring IoC 容器完成了 Bean 定义资源的定位、载入和解析注册后，IoC 容器就可以管理 Bean 定义的相关数据了。但是，此时 IoC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入是在以下两种情况下产生的：</p><p>1）当用户第一次调用 getBean() 方法时，IoC 容器触发依赖注入。</p><p>2）当用户在配置文件中将 <code>&lt;bean&gt;</code>元素配置了 <code>lazy-init=false</code> 属性时，IoC 容器才会进行预实例化，触发依赖注入。</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111813030.png" alt="image-20220711181326945"></p><h2 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring.xml&quot;</span>);<br><br><span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> (UserDao) context.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="执行-Bean-实例化"><a href="#执行-Bean-实例化" class="headerlink" title="执行 Bean 实例化"></a>执行 Bean 实例化</h2><p>点击上面中的 getBean() 方法，进入 AbstractBeanFactory 类中的 getBean()  方法中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">// 真正向 IoC 容器获取被管理的 Bean</span><br>    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="准备依赖注入"><a href="#准备依赖注入" class="headerlink" title="准备依赖注入"></a>准备依赖注入</h2><p>进入这个方法，它是获取 IoC 容器中指定名称和参数的 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">    String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>    <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    <span class="hljs-comment">// 根据指定名称获取被管理的 Bean 名称，剥离指定名称中对容器的相关依赖，如果指定的是别名，将别名转换为规范的 Bean 名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>    Object beanInstance;<br><br>    <span class="hljs-comment">// 先从缓存中读取是否已经有被创建过单例模式的 Bean,对于整个 IoC 容器单例 Bean 只会创建一次</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            <span class="hljs-comment">// 如果在容器中已有指定名称的单例模式的 Bean被创建，直接返回已经创建的Bean对象</span><br>            <span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>                <span class="hljs-comment">///</span><br>            &#125;<br>            <span class="hljs-comment">//</span><br>        &#125;<br>        <span class="hljs-comment">// 获取给定的 Bean 的实例对象，主要完成 FactoryBean 的相关处理</span><br>        <span class="hljs-comment">// 注意：BeanFactory是管理 Bean 的工厂，而 FactoryBean 是创建对象的工厂 Bean，两者是有区别的。</span><br>        beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存中没有真正在创建的单例模式的 Bean，而是存在原型模型的 Bean，但是由于有循环引用导致实例化对象创建失败</span><br>        <span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>        &#125;<br><br>        <span class="hljs-comment">// 对 IoC 容器中是否存在指定名称的 BeanDefinition 进行检查，首先检查是否能在当前的 BeanFactory 中获取所需要的</span><br>        <span class="hljs-comment">// Bean,如果不能则委托当前容器的父容器去查找，如果还是找不到则沿着容器的继承关系向父容器查找。</span><br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>        <span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>            <span class="hljs-comment">// 解析指定 Bean 名称的原始名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>            <span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory) &#123;<br>                <span class="hljs-keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(<br>                    nameToLookup, requiredType, args, typeCheckOnly);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 委托父容器根据指定名称和显示的参数查找</span><br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 委托父容器根据指定名称和类型查找</span><br>                <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建的 Bean 是否需要进行类型验证，一般不需要</span><br>        <span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>            <span class="hljs-comment">// 向容器标记指定的 Bean 已经被创建</span><br>            markBeanAsCreated(beanName);<br>        &#125;<br><br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanCreation</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.beans.instantiate&quot;</span>)<br>            .tag(<span class="hljs-string">&quot;beanName&quot;</span>, name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>                beanCreation.tag(<span class="hljs-string">&quot;beanType&quot;</span>, requiredType::toString);<br>            &#125;<br>            <span class="hljs-comment">// 根据指定 Bean 名称获得其父级 Bean 定义，主要解决 Bean 继承时子类和父类公共属性问题</span><br>            <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>            checkMergedBeanDefinition(mbd, beanName, args);<br><br>            <span class="hljs-comment">// 获取当前 Bean 所依赖的 Bean 名称</span><br>            String[] dependsOn = mbd.getDependsOn();<br>            <span class="hljs-comment">// 如果当前 Bean 有依赖</span><br>            <span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                    <span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                                        <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-comment">// 把被依赖的 Bean 注册给当前依赖的 Bean</span><br>                    registerDependentBean(dep, beanName);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 递归调用 getBean() 方法，获取当前 Bean 的所有依赖</span><br>                        getBean(dep);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>                                                        <span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 创建单例模式的 Bean 实例对象</span><br>            <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>                sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>                        <span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>                        <span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>                        <span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>                        destroySingleton(beanName);<br>                        <span class="hljs-keyword">throw</span> ex;<br>                    &#125;<br>                &#125;);<br>                beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>                <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforePrototypeCreation(beanName);<br>                    prototypeInstance = createBean(beanName, mbd, args);<br>                &#125;<br>                <span class="hljs-keyword">finally</span> &#123;<br>                    afterPrototypeCreation(beanName);<br>                &#125;<br>                beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>            &#125;<br><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>                <span class="hljs-keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No scope name defined for bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>                <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, () -&gt; &#123;<br>                        beforePrototypeCreation(beanName);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>                        &#125;<br>                        <span class="hljs-keyword">finally</span> &#123;<br>                            afterPrototypeCreation(beanName);<br>                        &#125;<br>                    &#125;);<br>                    beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            beanCreation.tag(<span class="hljs-string">&quot;exception&quot;</span>, ex.getClass().toString());<br>            beanCreation.tag(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));<br>            cleanupAfterBeanCreationFailure(beanName);<br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            beanCreation.end();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过向 IoC 容器获取 Bean 的方法的分析，我们可以看到，在 Spring 中如果 Bean 定义为单例模式，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean 定义为原型模式，则容器每次都会创建一个新的实例对象。</p><h2 id="开始实例化"><a href="#开始实例化" class="headerlink" title="开始实例化"></a>开始实例化</h2><p>点击上面代码中的 <code>return createBean(beanName, mbd, args);</code> 方法，进入AbstractAutowireCapableBeanFactory 类中的 createBean() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>    <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>    <span class="hljs-comment">//....省略</span><br>    <br>    <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbdToUse</span> <span class="hljs-operator">=</span> mbd;<br><br>    <span class="hljs-comment">// 判断所需要创建的 Bean是否可以实例化，即是否要通过当前的类加载器加载</span><br>    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br><br>    <span class="hljs-comment">// 校验和准备 Bean 中的方法覆盖</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        mbdToUse.prepareMethodOverrides();<br>    &#125;<br>    <span class="hljs-comment">//...省略</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果 Bean 配置了初始化前和初始化后的处理器，则试图返回一个需要创建的 Bean 代理对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//.....省略</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建 Bean 入口</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-comment">//.....省略</span><br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125;<br>    <span class="hljs-comment">//.....省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进入 <code>doCreateBean()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br><span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br><span class="hljs-comment">// 封装被创建的 Bean 对象</span><br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br>&#125;<br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>    <span class="hljs-comment">// 获取实例化对象的类型</span><br>Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br><span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>mbd.resolvedTargetType = beanType;<br>&#125;<br><br><span class="hljs-comment">// 调用 PostProcess 后置处理器</span><br><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br><span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>&#125;<br><span class="hljs-comment">//......省略</span><br>mbd.postProcessed = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 向容器中缓存单例模式的 Bean 对象，以防止循环引用</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>isSingletonCurrentlyInCreation(beanName));<br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br><span class="hljs-comment">//</span><br>&#125;<br>            <span class="hljs-comment">// 使用一个匿名内部类，为了防止循环引用，尽早持有对象的引用</span><br>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br><br><span class="hljs-comment">// Bean 对象的初始化，依赖注入在此处触发，这个 exposedObject 对象在初始化完成后返回依赖注入完成的 Bean</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 Bean 实例对象封装，并且将 Bean 定义中配置的属性赋给实例对象</span><br>populateBean(beanName, mbd, instanceWrapper);<br>            <span class="hljs-comment">// 初始化 Bean 对象</span><br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br><span class="hljs-comment">//.........</span><br><br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>            <span class="hljs-comment">// 获取指定名称的已注册的单例模式的 Bean 对象</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>                    <span class="hljs-comment">// 完成初始化</span><br>exposedObject = earlySingletonReference;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>String[] dependentBeans = getDependentBeans(beanName);<br>Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);<br><span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br><span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>actualDependentBeans.add(dependentBean);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br><span class="hljs-comment">//......</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 注册完成依赖注入的 Bean</span><br><span class="hljs-keyword">try</span> &#123;<br>registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>&#125;<br><span class="hljs-comment">//.....</span><br><br><span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源码注释可以看到，具体的依赖注入实现其实就在以下两个方法中：</p><p>1）createBeanInstance() 方法，生成 Bean 所包含的 Java 对象实例。</p><p>2）populateBean() 方法，对 Bean 属性的依赖注入进行处理。</p><p>进入 createBeanInstance() 方法，然后点击 instantiate() 方法，进入 SimpleInstantiationStrategy 类中的 instantiate() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner)</span> &#123;<br>    <span class="hljs-comment">// 如果 Bean 定义中没有方法覆盖，就不需要 CGLib 父类的方法</span><br>    <span class="hljs-keyword">if</span> (!bd.hasMethodOverrides()) &#123;<br>        Constructor&lt;?&gt; constructorToUse;<br>        <span class="hljs-keyword">synchronized</span> (bd.constructorArgumentLock) &#123;<br>            <span class="hljs-comment">// 获取对象的构造方法或工厂方法</span><br>            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;<br>            <span class="hljs-comment">// 如果没有构造器方法或工厂方法</span><br>            <span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 使用 JDK 的反射机制，判断要实例化的 Bean 是否是接口</span><br>                <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();<br>                <span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(clazz, <span class="hljs-string">&quot;Specified class is an interface&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>                        constructorToUse = AccessController.doPrivileged(<br>                            (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        constructorToUse = clazz.getDeclaredConstructor();<br>                    &#125;<br>                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(clazz, <span class="hljs-string">&quot;No default constructor found&quot;</span>, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 使用 BeanUtils 进行实例化，通过反射机制调用 构造器方法.newInstance(arg) 进行实例化</span><br>        <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(constructorToUse);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 使用 CGLib 来实例化对象</span><br>        <span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>在 Spring 中Bean的生命周期可以分为 4 类：</p><ul><li>Bean 自身方法</li><li>Bean 生命周期接口方法</li><li>容器级生命周期接口方法</li><li>工厂后处理器接口方法</li></ul><table><thead><tr><th>Spring Bean 生命周期</th><th>相关接口及方法</th></tr></thead><tbody><tr><td>Bean 自身方法</td><td>Bean 本身业务的方法：<br>配置文件中 init-method 和 destroy-method 指定的方法</td></tr><tr><td>Bean 生命周期接口方法</td><td>InitializingBean 接口<br>DisposableBean 接口<br>BeanNameAware 接口<br>ApplicationContextAware 接口<br>BeanFactoryAware 接口<br>其它</td></tr><tr><td>容器级生命周期接口方法<br>一般称为后处理器</td><td>InstantiationAwareBeanPostProcessor 接口实现<br>BeanPostProcessor 接口实现</td></tr><tr><td>工厂级生命周期接口方法<br>也可以归为容器级</td><td>AspectJWeavingEnabler<br>ConfigurationClassPostProcessor<br>CustomAutowireConfigurer 等</td></tr></tbody></table><p>一个 Bean 的生命周期需要经历以下时序：</p><ul><li>init-method：指定某个方法在 Bean 实例化完成，依赖关系设置结束后执行</li><li>detroy-method：指定某个方法在 Bean 销毁之前被执行</li><li>InitializingBean 接口：在 Bean 实例化完成，依赖关系设置结束后执行，在 init-method 之前执行</li><li>DisposableBean 接口：在指定 Bean Bean 销毁之前被执行，它是在 detroy-method 之前执行</li><li>ApplicationContextAware 接口：在实例化 Bean 时，为 Bean 注入 ApplicationContext</li></ul><h1 id="面试题：为什么要使用三级缓存来解决循环依赖"><a href="#面试题：为什么要使用三级缓存来解决循环依赖" class="headerlink" title="面试题：为什么要使用三级缓存来解决循环依赖"></a>面试题：为什么要使用三级缓存来解决循环依赖</h1><h2 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h2><p>所谓循环依赖，就是 A 的创建依赖于 B 的创建，B 的创建又依赖于 C 的创建，而 C 的创建又依赖于 A 的创建。</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111809026.png" alt="image-20220711180949895"></p><p>这就形成了循环依赖</p><h2 id="在Spring中使用循环依赖"><a href="#在Spring中使用循环依赖" class="headerlink" title="在Spring中使用循环依赖"></a>在Spring中使用循环依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BService bService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(bService);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AService aService;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.xianoupeng&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CycleDITest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);<br>        <span class="hljs-type">AService</span> <span class="hljs-variable">aService</span> <span class="hljs-operator">=</span> (AService) context.getBean(<span class="hljs-string">&quot;AService&quot;</span>);<br>        aService.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过测试发现，在 Spring 中已经帮我们解决一些循环依赖的问题。</p><h2 id="分析解决循环依赖的解决"><a href="#分析解决循环依赖的解决" class="headerlink" title="分析解决循环依赖的解决"></a>分析解决循环依赖的解决</h2><p>在 Spring 中，创建一个对象需要经过以下步骤：</p><p>1）利用构造器创建一个普通对象（也叫原始对象）</p><p>2）给对象的属性赋值，也就填充对象的属性值</p><p>3）填充其他属性</p><p>4）初始化前、初始化完成，以及其它操作</p><p>5）初始化后</p><p>6）把创建并初始化的对象放到单例池中（singletoObjects）里面。</p><p>在 Spring 中，通过以下三个 Map 对象来解决循环依赖问题：</p><p>1、一级缓存：singletonObjects，在这级缓存中已经经历完整的生命周期的 Bean 对象</p><p>2、二级缓存：earlySingletonObjects，比一级缓存多了一个 early，表示缓存的是早期的 Bean 对象，也就是 Bean 的生命周期还没有走完就把这个 Bean 放到了二级缓存中。</p><p>3、三级缓存：singletonFactories，缓存的是 ObjectFactory ，表示对象工厂，用来创建某个对象。</p><p>实际上，大多数据开发部下使用一级缓存就可以解决循环依赖问题，如果在循环依赖中存在一些循环的属性需要注入，比如 AOP 相关的数据需要注入，这时就需要使用 三级缓存来解决循环依赖问题。</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111810393.png" alt="image-20220711181002276"></p><p>从上图中可以发生，Spring 在处理循环依赖问题时，使用二级缓存就已经解决，但它不能解决复杂的循环依赖问题。要想解决复杂的循环依赖问题，就需要用到三级缓存。</p><p>处理循环依赖问题的源码：</p><p>AbstractAutowireCapableBeanFactory.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br><span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br><span class="hljs-comment">// Instantiate the bean.</span><br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br>&#125;<br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br><span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>mbd.resolvedTargetType = beanType;<br>&#125;<br><br><span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><br><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br><span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br><span class="hljs-string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);<br>&#125;<br>mbd.postProcessed = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 关键代码</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>isSingletonCurrentlyInCreation(beanName));<br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br><span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>&#125;<br>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br><br><span class="hljs-comment">// Initialize the bean instance.</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">try</span> &#123;<br>populateBean(beanName, mbd, instanceWrapper);<br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br><span class="hljs-comment">//.....</span><br><br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>            <span class="hljs-comment">// 核心</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>exposedObject = earlySingletonReference;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>String[] dependentBeans = getDependentBeans(beanName);<br>Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);<br><span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br><span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>actualDependentBeans.add(dependentBean);<br>&#125;<br>&#125;<br><span class="hljs-comment">///......</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// .....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进入 getSingleton() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br><span class="hljs-comment">// 从一级缓存中获取</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-comment">// 判断是否正在创建中</span><br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>            <span class="hljs-comment">// 从二缓存中获取</span><br>singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>            <span class="hljs-comment">// 如果没有找到并且允许循环引用</span><br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-comment">// 双重加锁</span><br>singletonObject = <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">// 从三级缓存中获取</span><br>ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br><span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-comment">// 执行 lambda 表达式</span><br>singletonObject = singletonFactory.getObject();<br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP（Aspect Oriented Programming）面向切面编程，它是面向对象编程的一种补充。</p><p>在 Spring 中，AOP 的实现有两种方式：</p><ul><li>使用 JDK 动态代理，要求被增强（代理）对象必须实现接口</li><li>使用 CGLib 动态代理</li></ul><p>在 Spring 中两种方式都有，如果被代理对象实现了接口就使用 JDK 动态代理，否则就使用 CGLib 动态代理。默认使用的是 JDK 动态代理。我们可以设置使用何种代理方式。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="1-横切关注点"><a href="#1-横切关注点" class="headerlink" title="1. 横切关注点"></a>1. 横切关注点</h3><p>简单的说，横切关注点就是可以对某些方法进行拦截，拦截后对原方法进行增强的处理。</p><h3 id="2-切面"><a href="#2-切面" class="headerlink" title="2. 切面"></a>2. 切面</h3><p>切面就是对横切关注点的抽象，这个关注点可能会横切多个对象。简单的说就是用于增强的类。</p><h3 id="3-连接点"><a href="#3-连接点" class="headerlink" title="3. 连接点"></a>3. 连接点</h3><p>连接点是在程序执行过程中某个特定的点，如某个方法调用时或者处理异常的时。</p><h3 id="4-切入点"><a href="#4-切入点" class="headerlink" title="4. 切入点"></a>4. 切入点</h3><p>在切面上拦截到某个特定的连接点之后执行的动作。</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>在 pom.xml 文件中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aopalliance<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aopalliance<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>编写接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编写两个实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.service.impl;<br><span class="hljs-keyword">import</span> org.example.service.Fruit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟吃水果的过程</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;吃苹果&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟吃香蕉的过程</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;吃香蕉&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编写切面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.aop;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitHandler</span> &#123;<br>    <span class="hljs-comment">// 打印开始吃水果时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startEatFruitDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">startDate</span> <span class="hljs-operator">=</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-string">&quot;开始吃水果的时间是：&quot;</span> + startDate);<br>    &#125;<br>    <span class="hljs-comment">// 打印结束吃水果时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endEatFruitDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">endDate</span> <span class="hljs-operator">=</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-string">&quot;结束吃水果的时间是：&quot;</span> + endDate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编写配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fruit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.service.impl.Apple&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fruit1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.service.impl.Banana&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置切面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fruitHandler&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.aop.FruitHandler&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>编写写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.aop.test;<br><br><span class="hljs-keyword">import</span> org.example.service.Fruit;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;<br><br><span class="hljs-meta">@ExtendWith(SpringExtension.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Fruit fruit;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Fruit fruit1;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> &#123;<br>        fruit.eat();<br><br>        System.out.println(<span class="hljs-string">&quot;-----------休息一会--------------&quot;</span>);<br><br>        fruit1.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后输出结果为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">吃苹果<br>-------------------休息一会------------------<br>吃香蕉<br></code></pre></td></tr></table></figure><p>现在我们希望在输出吃苹果时把花费的时间也输出，则需要添加如下配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置AOP --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置切面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;fruitHandler&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pt&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* org.example.service..*.*(..))&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;startEatFruitDate&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pt&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;endEatFruitDate&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pt&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果希望使用 AOP 的注解方式，则需要做以下调整：</p><p>1）在切面上添加 @Aspect 注解，然后在通过&#x2F;增强 方法上添加相应的增强的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.aop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 表示这是一个切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitHandler</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* org.example.service..*.*(..))&quot;)</span><br>    <span class="hljs-comment">// 打印开始吃水果时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startEatFruitDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">startDate</span> <span class="hljs-operator">=</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-string">&quot;开始吃水果的时间是：&quot;</span> + startDate);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;execution(* org.example.service..*.*(..))&quot;)</span><br>    <span class="hljs-comment">// 打印结束吃水果时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endEatFruitDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">endDate</span> <span class="hljs-operator">=</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-string">&quot;结束吃水果的时间是：&quot;</span> + endDate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）在Spring的配置文件中开启AOP注解支持，同时之前取消 AOP 的相关配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fruit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.service.impl.Apple&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fruit1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.service.impl.Banana&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置切面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fruitHandler&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.aop.FruitHandler&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 开启 AOP 注解的支持 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>3）再次运行测试程序就可以进行测试了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">开始吃水果的时间是：2022-07-11 10:54:17<br>吃苹果<br>结束吃水果的时间是：2022-07-11 10:54:18<br>-----------休息一会--------------<br>开始吃水果的时间是：2022-07-11 10:54:18<br>吃香蕉<br>结束吃水果的时间是：2022-07-11 10:54:19<br></code></pre></td></tr></table></figure><p>其实还可以优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.aop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 表示这是一个切面类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitHandler</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* org.example.service..*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//@Before(&quot;execution(* org.example.service..*.*(..))&quot;)</span><br>    <span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br>    <span class="hljs-comment">// 打印开始吃水果时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startEatFruitDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">startDate</span> <span class="hljs-operator">=</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-string">&quot;开始吃水果的时间是：&quot;</span> + startDate);<br>    &#125;<br><br>    <span class="hljs-comment">//@AfterReturning(&quot;execution(* org.example.service..*.*(..))&quot;)</span><br>    <span class="hljs-meta">@AfterReturning(&quot;pt()&quot;)</span><br>    <span class="hljs-comment">// 打印结束吃水果时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endEatFruitDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">endDate</span> <span class="hljs-operator">=</span> sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-string">&quot;结束吃水果的时间是：&quot;</span> + endDate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>数据库的事务是指将一系列的数据库操作当作一个逻辑单元，这个单元中的数据操作要么完全成功，要么完全失败。</p><h2 id="1-事务的特点"><a href="#1-事务的特点" class="headerlink" title="1. 事务的特点"></a>1. 事务的特点</h2><p>一个事务处理逻辑单元要成为事务，必须满足ACID属性：</p><ul><li>原子性（Atomicity）：一个事务内的操作不可再分，要么全部成功，要么全部失败。</li><li>一致性（Conisitency）：事务执行后，数据库的状态与其他业务逻辑保持一致。</li><li>隔离性（Isolation）：每个事务运行都是相互独立的，互不干绕。</li><li>持久性（Druability）：事务一旦提交，就会永久保存下来。</li></ul><h2 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2. 事务隔离级别"></a>2. 事务隔离级别</h2><p>事务隔离级别有 4 个：</p><ul><li>READ_UNCOMMITED：读取未提交，会产生“脏读”数据，必须要避免的。</li><li>READ_COMMITED：读已提交事务，会产生“幻读”数据。</li><li>REPEATABLE_READ：可重复读，会产生“幻读”数据。</li><li>SERIALIZABLE：它是一个串行读。</li></ul><p>事务隔离级别是从上往下的安全性增加，但是性能降低。</p><h2 id="3-事务传播行为"><a href="#3-事务传播行为" class="headerlink" title="3. 事务传播行为"></a>3. 事务传播行为</h2><p>事务传播行为有 7 个：</p><table><thead><tr><th>事务传播行为类型</th><th>说        明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务。<br>如果已经存在一个事务中，加入到这就个事务中</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务。如果当前没有事务，就以非事务方式执行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务。如果当前没有事务，就抛出异常</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务。如果当前存在事务，把当前事务挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作。如果当前存在事务，就把当前事务挂起</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行。如果当前存在事务，则抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。<br>如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。<br>与 PROPAGATION_REQUIRES_NEW 的差别是 PROPAGATION_REQUIRES_NEW 另起一个事务，将会与其父事务相互独立。<br>PROPAGATION_NESTED 事务和其父事务是相依的，其要等父事务一起提交。</td></tr></tbody></table><h2 id="4-事务配置"><a href="#4-事务配置" class="headerlink" title="4. 事务配置"></a>4. 事务配置</h2><p>1）XML 配置方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-comment">&lt;!-- 配置事务通知 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 配置哪些方法需要有事务 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transfer&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;DEFAULT&quot;</span>/&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;del*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>           <span class="hljs-comment">&lt;!-- 哪些方法不需要有事务 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 配置 AOP --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pt&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.jock.tx.service..*.*(..))&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pt&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）注解方式</p><p>A、在需要添加事务的类或方法上使用 @Transactional(propagation &#x3D; Propagation.SUPPORTS, readOnly &#x3D; true)</p><p>B、在配置文件添加注解的支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.jock.tx&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 添加事务注解支持 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Spring-MVC-复习"><a href="#Spring-MVC-复习" class="headerlink" title="Spring MVC 复习"></a>Spring MVC 复习</h1><p>Spring MVC 框架中封装的就是 Servlet。</p><h2 id="有-web-xml-的方式"><a href="#有-web-xml-的方式" class="headerlink" title="有 web.xml 的方式"></a>有 web.xml 的方式</h2><h3 id="1）创建一个工程"><a href="#1）创建一个工程" class="headerlink" title="1）创建一个工程"></a>1）创建一个工程</h3><p> <img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111810726.png" alt="image-20220711181032626"></p><h3 id="2）添加依赖"><a href="#2）添加依赖" class="headerlink" title="2）添加依赖"></a>2）添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>framework-spring-mvc-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3）创建-web-xml-文件"><a href="#3）创建-web-xml-文件" class="headerlink" title="3）创建 web.xml 文件"></a>3）创建 web.xml 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4）创建Spring配置文件"><a href="#4）创建Spring配置文件" class="headerlink" title="4）创建Spring配置文件"></a>4）创建Spring配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.jock&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 在Spring中排除扫描 @Controller 注解 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5）编写SpringMVC配置文件"><a href="#5）编写SpringMVC配置文件" class="headerlink" title="5）编写SpringMVC配置文件"></a>5）编写SpringMVC配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 关闭默认的扫描规则，按我们自己指定的规则来扫描 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.jock&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6）编写实现类"><a href="#6）编写实现类" class="headerlink" title="6）编写实现类"></a>6）编写实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.jock.entity;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.experimental.Accessors;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7）编写数据访问层"><a href="#7）编写数据访问层" class="headerlink" title="7）编写数据访问层"></a>7）编写数据访问层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.jock.dao;<br><br><span class="hljs-keyword">import</span> org.jock.entity.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.jock.dao.impl;<br><br><span class="hljs-keyword">import</span> org.jock.dao.UserDao;<br><span class="hljs-keyword">import</span> org.jock.entity.User;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, User&gt; data;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span> &#123;<br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, User&gt; entry : data.entrySet()) &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> entry.getValue();<br>            users.add(user);<br>        &#125;<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        data.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>().setId(<span class="hljs-number">1</span>).setName(<span class="hljs-string">&quot;刘备&quot;</span>));<br>        data.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>().setId(<span class="hljs-number">2</span>).setName(<span class="hljs-string">&quot;关羽&quot;</span>));<br>        data.put(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>().setId(<span class="hljs-number">3</span>).setName(<span class="hljs-string">&quot;张飞&quot;</span>));<br>        data.put(<span class="hljs-number">4</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>().setId(<span class="hljs-number">4</span>).setName(<span class="hljs-string">&quot;赵云&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8）编写业务层"><a href="#8）编写业务层" class="headerlink" title="8）编写业务层"></a>8）编写业务层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.jock.service;<br><br><span class="hljs-keyword">import</span> org.jock.entity.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.jock.service.impl;<br><br><span class="hljs-keyword">import</span> org.jock.dao.UserDao;<br><span class="hljs-keyword">import</span> org.jock.entity.User;<br><span class="hljs-keyword">import</span> org.jock.service.UserService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userDao.list();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9）编写控制器"><a href="#9）编写控制器" class="headerlink" title="9）编写控制器"></a>9）编写控制器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.jock.controller;<br><br><span class="hljs-keyword">import</span> org.jock.entity.User;<br><span class="hljs-keyword">import</span> org.jock.service.UserService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.ui.Model;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">(Model model)</span> &#123;<br>        List&lt;User&gt; users = userService.getAll();<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, users.get(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10）加载Spring容器"><a href="#10）加载Spring容器" class="headerlink" title="10）加载Spring容器"></a>10）加载Spring容器</h3><p>在 web.xml 文件中加载 Spring 配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>spring<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath*:spring*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>spring<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="11）启动服务测试"><a href="#11）启动服务测试" class="headerlink" title="11）启动服务测试"></a>11）启动服务测试</h3><p>在地址栏中输入：<a href="http://localhost:8080/framework-spring-mvc-xml/list">http://localhost:8080/framework-spring-mvc-xml/list</a></p><p>得到结果为：1 - 刘备</p><h2 id="纯注解方式"><a href="#纯注解方式" class="headerlink" title="纯注解方式"></a>纯注解方式</h2><h3 id="1）创建工程"><a href="#1）创建工程" class="headerlink" title="1）创建工程"></a>1）创建工程</h3><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111812495.png" alt="image-20220711181241389"></p><h3 id="2）添加依赖-1"><a href="#2）添加依赖-1" class="headerlink" title="2）添加依赖"></a>2）添加依赖</h3><p>在 pom.xml 文件中添加与上面的依赖相同。</p><h3 id="3）配置容器"><a href="#3）配置容器" class="headerlink" title="3）配置容器"></a>3）配置容器</h3><p>我们在项目中创建一个 config 包，在这个包下创建一个 ApplicationConifg.java 类，它的作用就对应 web.xml 中的 ContextLoaderListener 的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jock.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.FilterType;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置类，它的作用与 spring.xml 相同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">        value = &quot;com.jock&quot;,</span><br><span class="hljs-meta">        excludeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION, value = Controller.class)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationConfig</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）环境配置"><a href="#4）环境配置" class="headerlink" title="4）环境配置"></a>4）环境配置</h3><p>由于从 Servlet 3.x 开始，Web 项目就开始支持无 web.xml 文件的方式。虽然文件可以没有，但它的功能需要转换为配置文件。所以我们在 config 包下再创建一个 WebConfig.java 文件，它对应 DispatcherServlet 配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jock.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.FilterType;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 它相当于 springmvc.xml 文件</span><br><span class="hljs-comment"> * 这个配置类需要实现 WebMvcConfigurer 类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@EnableWebMvc</span> 注解的作用是开启web功能</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.jock&quot;, includeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">// 添加视图解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title function_">viewResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InternalResourceViewResolver</span> <span class="hljs-variable">viewResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalResourceViewResolver</span>();<br>        viewResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/views/&quot;</span>);<br>        viewResolver.setSuffix(<span class="hljs-string">&quot;.jsp&quot;</span>);<br>        <span class="hljs-keyword">return</span> viewResolver;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）加载容器"><a href="#5）加载容器" class="headerlink" title="5）加载容器"></a>5）加载容器</h3><p>在项目中创建 init 包，并在这个包下创建 SpringApplicationInitializer，此类实现了 WebApplicationInitializer 接口，在 Spring 容器启动时会自动加载这个接口的所有实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jock.init;<br><br><span class="hljs-keyword">import</span> com.jock.config.ApplicationConfig;<br><span class="hljs-keyword">import</span> com.jock.config.WebConfig;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加载容器类，这个类要继承 AbstractAnnotationConfigDispatcherServletInitializer 类，它是 WebApplicationInitializer 接口的子类</span><br><span class="hljs-comment"> * 然后重写以下几个方法：</span><br><span class="hljs-comment"> * 1. getRootConfigClasses()：用于加载 Spring 的配置类,ApplicationConfig.class</span><br><span class="hljs-comment"> * 2. getServletConfigClasses()：用于加载 SpringMVC 的配置类，WebConfig.class</span><br><span class="hljs-comment"> * 3. getServletMappings()：用于指定请求的映射</span><br><span class="hljs-comment"> * 其实这个类的作用就类似于 web.xml 文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringApplicationInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;ApplicationConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;WebConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// url-mapping</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）编写其它程序"><a href="#6）编写其它程序" class="headerlink" title="6）编写其它程序"></a>6）编写其它程序</h3><p>接下来编写实体类、访问层、业务层、控制层和 index.jsp 页面。内容参考 xml 项目。</p><h3 id="7）启动测试"><a href="#7）启动测试" class="headerlink" title="7）启动测试"></a>7）启动测试</h3><p>启动项目，输入访问地址：<a href="http://localhost:8080/framework-spring-mvc-annotation/list">http://localhost:8080/framework-spring-mvc-annotation/list</a> 就可以正常的访问。</p><p>我们还可以 WebConfig.java 配置类中，添加默认的请求资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 配置默认访问路径</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> &#123;<br>    registry<br>            .addViewController(<span class="hljs-string">&quot;/&quot;</span>) <span class="hljs-comment">// 添加请求的访问路径</span><br>            .setViewName(<span class="hljs-string">&quot;login&quot;</span>); <span class="hljs-comment">// 设置访问路径对应的视图</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringMVC-执行流程"><a href="#SpringMVC-执行流程" class="headerlink" title="SpringMVC 执行流程"></a>SpringMVC 执行流程</h2><h3 id="1-请求流程"><a href="#1-请求流程" class="headerlink" title="1. 请求流程"></a>1. 请求流程</h3><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111808370.png" alt="image-20220711145727052"></p><h3 id="2-初始化过程"><a href="#2-初始化过程" class="headerlink" title="2. 初始化过程"></a>2. 初始化过程</h3><p>由于 DispatchServlet 是整个 SpringMVC 的核心，所以我们进入这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatcherServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FrameworkServlet</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到父类 HttpServletBean 中的 init() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>    <span class="hljs-comment">// Set bean properties from init parameters.</span><br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletConfigPropertyValues</span>(getServletConfig(), <span class="hljs-built_in">this</span>.requiredProperties);<br>    <span class="hljs-keyword">if</span> (!pvs.isEmpty()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 定位资源</span><br>            <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> PropertyAccessorFactory.forBeanPropertyAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">// 加载配置信息</span><br>            <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextResourceLoader</span>(getServletContext());<br>            bw.registerCustomEditor(Resource.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEditor</span>(resourceLoader, getEnvironment()));<br>            initBeanWrapper(bw);<br>            bw.setPropertyValues(pvs, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//.....省略</span><br>    &#125;<br><br>    <span class="hljs-comment">// Let subclasses do whatever initialization they like.</span><br>    initServletBean();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法是获取 web.xml 中配置的属性参数，并将这些属性设置到 DispatcherServlet 中，init() 方法中还包含一个模板方法 <code>initServletBean();</code>，该方法需要其子类来实现。</p><p>HttpServletBean 类的子类为 FrameworkServlet 类，因此我们查看这个类中的 initServletBean()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initServletBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    getServletContext().log(<span class="hljs-string">&quot;Initializing Spring &quot;</span> + getClass().getSimpleName() + <span class="hljs-string">&quot; &#x27;&quot;</span> + getServletName() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    <span class="hljs-comment">//....省略</span><br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.webApplicationContext = initWebApplicationContext();<br>        initFrameworkServlet();<br>    &#125;<br>    <span class="hljs-comment">//....省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，最核心的就是 <code>initWebApplicationContext()</code> 方法，进入这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">initWebApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">rootContext</span> <span class="hljs-operator">=</span><br>        WebApplicationContextUtils.getWebApplicationContext(getServletContext());<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.webApplicationContext != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// A context instance was injected at construction time -&gt; use it</span><br>        wac = <span class="hljs-built_in">this</span>.webApplicationContext;<br>        <span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;<br>            <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">cwac</span> <span class="hljs-operator">=</span> (ConfigurableWebApplicationContext) wac;<br>            <span class="hljs-keyword">if</span> (!cwac.isActive()) &#123;<br>                <span class="hljs-comment">// The context has not yet been refreshed -&gt; provide services such as</span><br>                <span class="hljs-comment">// setting the parent context, setting the application context id, etc</span><br>                <span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// The context instance was injected without an explicit parent -&gt; set</span><br>                    <span class="hljs-comment">// the root application context (if any; may be null) as the parent</span><br>                    cwac.setParent(rootContext);<br>                &#125;<br>                configureAndRefreshWebApplicationContext(cwac);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// No context instance was injected at construction time -&gt; see if one</span><br>        <span class="hljs-comment">// has been registered in the servlet context. If one exists, it is assumed</span><br>        <span class="hljs-comment">// that the parent context (if any) has already been set and that the</span><br>        <span class="hljs-comment">// user has performed any initialization such as setting the context id</span><br>        wac = findWebApplicationContext();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// No context instance is defined for this servlet -&gt; create a local one</span><br>        wac = createWebApplicationContext(rootContext);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.refreshEventReceived) &#123;<br>        <span class="hljs-comment">// Either the context is not a ConfigurableApplicationContext with refresh</span><br>        <span class="hljs-comment">// support or the context injected at construction time had already been</span><br>        <span class="hljs-comment">// refreshed -&gt; trigger initial onRefresh manually here.</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.onRefreshMonitor) &#123;<br>            onRefresh(wac);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.publishContext) &#123;<br>        <span class="hljs-comment">// Publish the context as a servlet context attribute.</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">attrName</span> <span class="hljs-operator">=</span> getServletContextAttributeName();<br>        getServletContext().setAttribute(attrName, wac);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的方法中可以发现，都时在创建 WebApplicationContext 对象，其中有一个方法叫 <code>createWebApplicationContext(rootContext);</code> 进入这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createWebApplicationContext</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> WebApplicationContext parent)</span> &#123;<br>    <span class="hljs-keyword">return</span> createWebApplicationContext((ApplicationContext) parent);<br>&#125;<br><br><br><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createWebApplicationContext</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span> &#123;<br>    Class&lt;?&gt; contextClass = getContextClass();<br>    <span class="hljs-comment">//....省略</span><br>    <br>    <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span><br>        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);<br><br>    wac.setEnvironment(getEnvironment());<br>    wac.setParent(parent);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">configLocation</span> <span class="hljs-operator">=</span> getContextConfigLocation();<br>    <span class="hljs-keyword">if</span> (configLocation != <span class="hljs-literal">null</span>) &#123;<br>        wac.setConfigLocation(configLocation);<br>    &#125;<br>    configureAndRefreshWebApplicationContext(wac);<br><br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该方法中使用 BeanUtils 工具类的 instantiateClass() 方法来通过反射的机制创建 Web 上下文对象，即 ConfigurableWebApplicationContext 对象。并且将 web.xml 中的配置的 contextConfigLocation 变量设置到该对象中。最刷新容器。</p><p>点击 <code>configureAndRefreshWebApplicationContext(wac)</code> 方法并进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureAndRefreshWebApplicationContext</span><span class="hljs-params">(ConfigurableWebApplicationContext wac)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;<br>        <span class="hljs-comment">// The application context id is still set to its original default value</span><br>        <span class="hljs-comment">// -&gt; assign a more useful id based on available information</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.contextId != <span class="hljs-literal">null</span>) &#123;<br>            wac.setId(<span class="hljs-built_in">this</span>.contextId);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Generate default id...</span><br>            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +<br>                      ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="hljs-string">&#x27;/&#x27;</span> + getServletName());<br>        &#125;<br>    &#125;<br><br>    wac.setServletContext(getServletContext());<br>    wac.setServletConfig(getServletConfig());<br>    wac.setNamespace(getNamespace());<br>    wac.addApplicationListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SourceFilteringListener</span>(wac, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextRefreshListener</span>()));<br><br>    <span class="hljs-comment">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span><br>    <span class="hljs-comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br>    <span class="hljs-comment">// use in any post-processing or initialization that occurs below prior to #refresh</span><br>    <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> wac.getEnvironment();<br>    <span class="hljs-keyword">if</span> (env <span class="hljs-keyword">instanceof</span> ConfigurableWebEnvironment) &#123;<br>        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());<br>    &#125;<br><br>    postProcessWebApplicationContext(wac);<br>    applyInitializers(wac);<br>    wac.refresh();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中最后一行是 <code>wac.refresh();</code> ，作用是进行容器的刷新操作，点击这个方法进入就可以进入 IoC 容器了。后面的代码就不再分析，昨天已经分析过了。</p><p>回到 FrameworkServlet 类中的 initWebApplicationContext() 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">initWebApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">rootContext</span> <span class="hljs-operator">=</span><br>        WebApplicationContextUtils.getWebApplicationContext(getServletContext());<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//....省略</span><br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.refreshEventReceived) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.onRefreshMonitor) &#123;<br>            onRefresh(wac);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//....省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进入 <code>onRefresh(wac);</code> 方法中，会进入  DispatchServlet 类中 onRefresh() 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRefresh</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    initStrategies(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>它会调用本类中 initStrategies() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    <span class="hljs-comment">// 初始化用户处理文件上传</span><br>    initMultipartResolver(context);<br>    <span class="hljs-comment">// 初始化处理国际化</span><br>    initLocaleResolver(context);<br>    <span class="hljs-comment">// 初始化处理主题</span><br>    initThemeResolver(context);<br>    <span class="hljs-comment">// 初始化处理请求映射，其实就是调用 Controller中的方法</span><br>    initHandlerMappings(context);<br>    <span class="hljs-comment">// 初始化参数适配器</span><br>    initHandlerAdapters(context);<br>    <span class="hljs-comment">// 初始化异常处理解析器</span><br>    initHandlerExceptionResolvers(context);<br>    <span class="hljs-comment">// 初始化视图预处理器</span><br>    initRequestToViewNameTranslator(context);<br>    <span class="hljs-comment">// 初始化视图解析器</span><br>    initViewResolvers(context);<br>    <span class="hljs-comment">// 初始化 FlashMap 映射管理器</span><br>    initFlashMapManager(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个模板策略方法。对于初始化策略方法 initStrategies() ，在不指定个性化配置文件的情况下，会使用默认的配置进行初始化，默认配置位于 DispatcherServlet.properties 配置文件。这个配置文件在 spring-webmvc.jar 文件中。</p><p> <img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207111808611.png" alt="image-20220711180810533"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.web.servlet.LocaleResolver</span>=<span class="hljs-string">org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><br><span class="hljs-attr">org.springframework.web.servlet.ThemeResolver</span>=<span class="hljs-string">org.springframework.web.servlet.theme.FixedThemeResolver</span><br><br><span class="hljs-attr">org.springframework.web.servlet.HandlerMapping</span>=<span class="hljs-string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="hljs-string">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span><br><span class="hljs-string">org.springframework.web.servlet.function.support.RouterFunctionMapping</span><br><br><span class="hljs-attr">org.springframework.web.servlet.HandlerAdapter</span>=<span class="hljs-string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="hljs-string">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="hljs-string">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span><br><span class="hljs-string">org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span><br><br><br><span class="hljs-attr">org.springframework.web.servlet.HandlerExceptionResolver</span>=<span class="hljs-string">org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="hljs-string">org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="hljs-string">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><br><span class="hljs-attr">org.springframework.web.servlet.RequestToViewNameTranslator</span>=<span class="hljs-string">org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><br><span class="hljs-attr">org.springframework.web.servlet.ViewResolver</span>=<span class="hljs-string">org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><br><span class="hljs-attr">org.springframework.web.servlet.FlashMapManager</span>=<span class="hljs-string">org.springframework.web.servlet.support.SessionFlashMapManager</span><br></code></pre></td></tr></table></figure><p>我们查看用于处理请求映射的 <code>initHandlerMappings(context);</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initHandlerMappings</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    <span class="hljs-built_in">this</span>.handlerMappings = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.detectAllHandlerMappings) &#123;<br>        <span class="hljs-comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span><br>        Map&lt;String, HandlerMapping&gt; matchingBeans =<br>            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;<br>            <span class="hljs-built_in">this</span>.handlerMappings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());<br>            <span class="hljs-comment">// We keep HandlerMappings in sorted order.</span><br>            AnnotationAwareOrderComparator.sort(<span class="hljs-built_in">this</span>.handlerMappings);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">HandlerMapping</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);<br>            <span class="hljs-built_in">this</span>.handlerMappings = Collections.singletonList(hm);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>            <span class="hljs-comment">// Ignore, we&#x27;ll add a default HandlerMapping later.</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Ensure we have at least one HandlerMapping, by registering</span><br>    <span class="hljs-comment">// a default HandlerMapping if no other mappings are found.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerMappings == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No HandlerMappings declared for servlet &#x27;&quot;</span> + getServletName() +<br>                         <span class="hljs-string">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (HandlerMapping mapping : <span class="hljs-built_in">this</span>.handlerMappings) &#123;<br>        <span class="hljs-keyword">if</span> (mapping.usesPathPatterns()) &#123;<br>            <span class="hljs-built_in">this</span>.parseRequestPath = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上部分就是初始化的过程。</p><h3 id="3-执行过程"><a href="#3-执行过程" class="headerlink" title="3. 执行过程"></a>3. 执行过程</h3><p>我在学习 JavaWeb 时，知道 Servlet 的规范，它最顶层的接口是 Servlet，里面含有 service() 方法，这个方法就是用于处理请求的方法。</p><p>在 Spring MVC 中的 FrameworkServlet 类继承了 HttpServlet，并重写了 service() 方法。因此我们查看这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>    <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>    <span class="hljs-type">HttpMethod</span> <span class="hljs-variable">httpMethod</span> <span class="hljs-operator">=</span> HttpMethod.resolve(request.getMethod());<br>    <span class="hljs-keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="hljs-literal">null</span>) &#123;<br>        processRequest(request, response);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.service(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 FrameworkServlet  是 Spring 中的类，它扩展了 HttpServlet的功能，新增了 <code>processRequest(request, response)</code> 方法。我们回到 HttServlet类中，除了 service() 方法外，还有 doGet()、doPost()、doDelete() 等方法。在 FrameworkServlet  中已经把这些方法进行重写，比如 doGet()就去，在 HttpServlet 中定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>    <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> req.getProtocol();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> lStrings.getString(<span class="hljs-string">&quot;http.method_get_not_supported&quot;</span>);<br>    <span class="hljs-keyword">if</span> (protocol.endsWith(<span class="hljs-string">&quot;1.1&quot;</span>)) &#123;<br>        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在 FrameworkServlet 类中重写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>    <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>    processRequest(request, response);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们就进入 <code>processRequest()</code> 方法来进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>    <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">failureCause</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">LocaleContext</span> <span class="hljs-variable">previousLocaleContext</span> <span class="hljs-operator">=</span> LocaleContextHolder.getLocaleContext();<br>    <span class="hljs-type">LocaleContext</span> <span class="hljs-variable">localeContext</span> <span class="hljs-operator">=</span> buildLocaleContext(request);<br><br>    <span class="hljs-type">RequestAttributes</span> <span class="hljs-variable">previousAttributes</span> <span class="hljs-operator">=</span> RequestContextHolder.getRequestAttributes();<br>    <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> buildRequestAttributes(request, response, previousAttributes);<br><br>    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br>    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestBindingInterceptor</span>());<br><br>    initContextHolders(request, localeContext, requestAttributes);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        doService(request, response);<br>    &#125;<br>    <span class="hljs-comment">//....省略</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中做了很多的事情，比较复杂，其中我们先最需要关注的是处理请求的 <code>doService()</code> 方法。点击这个方法后可以发现它是 FrameworkServlet 中的一个抽象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br><span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><p>所以其实是 DistatcherServlet 这个子类来具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    logRequest(request);<br><br>    <span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span><br>    <span class="hljs-comment">// to be able to restore the original attributes after the include.</span><br>    Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;<br>        attributesSnapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();<br>        <span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">attrName</span> <span class="hljs-operator">=</span> (String) attrNames.nextElement();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;<br>                attributesSnapshot.put(attrName, request.getAttribute(attrName));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Make framework objects available to handlers and view objects.</span><br>    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());<br>    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.localeResolver);<br>    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.themeResolver);<br>    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.flashMapManager != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">FlashMap</span> <span class="hljs-variable">inputFlashMap</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);<br>        <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-literal">null</span>) &#123;<br>            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));<br>        &#125;<br>        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlashMap</span>());<br>        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-built_in">this</span>.flashMapManager);<br>    &#125;<br><br>    <span class="hljs-type">RequestPath</span> <span class="hljs-variable">previousRequestPath</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parseRequestPath) &#123;<br>        previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);<br>        ServletRequestPathUtils.parseAndCache(request);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        doDispatch(request, response);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span><br>            <span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-literal">null</span>) &#123;<br>                restoreAttributesAfterInclude(request, attributesSnapshot);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parseRequestPath) &#123;<br>            ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 FrameworkServlet 类中的 doService() 方法其实调用了 DispatcherSeverlet 类中的 doDispatch() 方法。这个方法将寻找合适的处理方式来执行请求。进入 doDipatch() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 视图对象</span><br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Exception</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1. 检查是否为文件上传的请求</span><br>            processedRequest = checkMultipart(request);<br>            multipartRequestParsed = (processedRequest != request);<br><br>            <span class="hljs-comment">// 2. 获取当前请求的 Controller（也就是 Handler），即处理器</span><br>            mappedHandler = getHandler(processedRequest);<br>            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如处理器没有找到则抛出 404 错误</span><br>                noHandlerFound(processedRequest, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 3. 获取处理请求的处理器适配器 HandleAdapter</span><br>            <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());<br><br>            <span class="hljs-comment">// 处理 last-moddified 请求头</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> HttpMethod.GET.matches(method);<br>            <span class="hljs-keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 4. 实现处理请求的处理器，执行后会返回视图对象</span><br>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 结果视图对象的处理</span><br>            applyDefaultViewName(processedRequest, mv);<br>            mappedHandler.applyPostHandle(processedRequest, response, mv);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            dispatchException = ex;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>            <span class="hljs-comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span><br>            <span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span><br>            dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, err);<br>        &#125;<br>        <span class="hljs-comment">// 处理结果</span><br>        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler,<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, err));<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-comment">// Instead of postHandle and afterCompletion</span><br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 请求成功响应之后的方法。</span><br>                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Clean up any resources used by a multipart request.</span><br>            <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>                cleanupMultipart(processedRequest);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来分析 getHandler() 方法，看它是如何来找到请求对应的处理程序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerMappings != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (HandlerMapping mapping : <span class="hljs-built_in">this</span>.handlerMappings) &#123;<br>            <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> mapping.getHandler(request);<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> handler;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法中是把默认加载（DipathcerServlet.properties）或者我们自定义的拦截器（处理器），然后进行逐个遍历，如果某个处理器能够正确执行请求，则结束遍历并返回。</p>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList、ArrayList插入分析</title>
    <link href="/2022/07/08/2022-7-8-LinkedList%E3%80%81ArrayList%E6%8F%92%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/08/2022-7-8-LinkedList%E3%80%81ArrayList%E6%8F%92%E5%85%A5%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h1><p><code>ArrayList</code>基于数组进行实现，<code>LinkedList</code>基于链表进行实现，所以基于数据结构的不同，遍历和查找多的情况下用 <code>ArrayList</code>、插入和删除频繁的情况下用 <code>LinkedList</code>，但是，这并不意味这<code>LinkedList</code>的插入效率一定比<code>ArrayList</code>好，当我们只需要在结尾插数据时，<code>ArryList</code>的效率是高于<code>LinkedList</code>的</p><p>所以还需要具体情况具体分析</p><h1 id="LinkedList数据结构"><a href="#LinkedList数据结构" class="headerlink" title="LinkedList数据结构"></a>LinkedList数据结构</h1><p><code>LinkedList</code>，是基于链表实现，由双向链条<code>next</code>、<code>prev</code>，把数据节点穿插起来。所以，在插入数据时，是不需要像我们上一章介绍的<code>ArrayList</code>那样，扩容数组</p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081133374.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>与<code>ArrayList</code>不同，<code>LinkedList</code>的初始化不需要创建数组，因为它是一个链表结构，而且也没有传给构造函数初始化多少个空间的入参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    addAll(c);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化方式；普通方式</span><br>LinkedList&lt;String&gt; list01 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>list01.add(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-comment">// 初始化方式；Arrays.asList</span><br>LinkedList&lt;String&gt; list02 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>));<br><br><span class="hljs-comment">// 初始化方式；Collections.nCopies</span><br>LinkedList&lt;Integer&gt; list04 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;(Collections.nCopies(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 10个0</span><br></code></pre></td></tr></table></figure><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p><code>LinkedList</code>插入方法比较多，<code>List</code>中接口默认提供的是<code>add</code>，也可以指定位置插入，但是在<code>LinkedList</code>中还提供了头插<code>addFirst</code>和尾插<code>addLast</code></p><h2 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081143472.png" alt="image-20220708114308409"></p><ol><li><code>ArrayList</code>头插时，需要把元素通过<code>Arrays.copyOf</code>的方式把数组元素移位，如果容量不足还需要扩容</li><li><code>LinkedList</code>头插时，则不需要考虑扩容以及移位问题，直接把元素定位首位，插入即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f); <span class="hljs-comment">// 新的节点元素</span><br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        last = newNode;<br>    <span class="hljs-keyword">else</span><br>        f.prev = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><p>在插入的时候只需要去创建新的节点元素，<code>new Node&lt;&gt;(null,e,f)</code>，接着把新的头元素赋值给<code>first</code>，后面判读f节点存在否，不存在就把头插节点作为最后一个节点，存在则用<code>f.prev</code>链接当前节点</p><p><strong>对比</strong>：<code>LinkedList </code>更优</p><p>在只进行头插的视乎，<code>ArrayList </code>需要做大量的位移和复制操作，而<code>LinkedList </code>的优势就体现出来了，耗时只是实例化一个对象</p><h2 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081148335.png" alt="image-20220708114844272"></p><ol><li><code>ArrayList </code>尾插时，是不需要数据位移的，比较耗时的是数据的扩容时，需要拷贝迁移</li><li><code>LinkedList</code> 尾插时，与头插相比耗时点会在对象的实例化上</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>与头插代码相比几乎没有什么区别，只是<code>first</code>换成<code>last</code></li><li>耗时只是在创建节点上，<code>Node&lt;E&gt;</code></li></ul><p><strong>对比</strong>：<code>ArrayList </code>更优</p><h2 id="中间插"><a href="#中间插" class="headerlink" title="中间插"></a>中间插</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081346021.png" alt="image-20220708134635927"></p><ol><li><code>ArrayList</code>中间插入，首先我们知道他的定位时间复杂度是O(1)，比较耗时的点在于数据迁移和容量不足时候的扩容</li><li><code>LinkedList</code>中间插入，链表的数据实际插入时候并不会怎么耗时，但是他定位的元素的时间复杂度是O(n)，所以这部分以及元素的实例化比较耗时</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    checkPositionIndex(index);<br><br>    <span class="hljs-keyword">if</span> (index == size)<br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        linkBefore(element, node(index));<br>&#125;<br><br><span class="hljs-comment">// 定位元素</span><br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 正式插入</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>    <span class="hljs-comment">// assert succ != null;</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>    succ.prev = newNode;<br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        pred.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>找到指定位置插入的过程就比较简单了，与头插、尾插，相差不大</li><li>整个过程可以看到，插入中比较耗时的点会在遍历寻找插入位置上</li></ul><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081352539.png" alt="image-20220708135241491"></p><p>通过测试可以看到 <code>Linkedlist </code>在中间插入时，遍历寻找位置还是非常耗时了。所以不同的情况下，需要选择不同的 <code>List </code>集合做业务</p><p><strong>对比</strong>：<code>ArrayList </code>更优</p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081355824.png" alt="image-20220708135526764"></p><p><strong>以<code>remove()</code>为例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="hljs-literal">null</span>; x = x.next) &#123;<br>            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;<br>                unlink(x);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// unlink(x)解链</span><br>E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        first = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.next = next;<br>        x.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next.prev = prev;<br>        x.next = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    x.item = <span class="hljs-literal">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">xx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>    list.add(i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_LinkedList_for0</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>        xx += list.get(i);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - startTime));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_LinkedList_for1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (Integer itr : list) &#123;<br>        xx += itr;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - startTime));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Iterator循环"><a href="#Iterator循环" class="headerlink" title="Iterator循环"></a>Iterator循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_LinkedList_Iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    Iterator&lt;Integer&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>        xx += next;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - startTime))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_LinkedList_forEach</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    list.forEach(integer -&gt; &#123;<br>        xx += integer;<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - startTime));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_LinkedList_stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    list.stream().forEach(integer -&gt; &#123;<br>        xx += integer;<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - startTime));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>ArrayList</tag>
      
      <tag>LinkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双端队列、延迟队列、阻塞队列</title>
    <link href="/2022/07/08/2022-7-8-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E3%80%81%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <url>/2022/07/08/2022-7-8-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E3%80%81%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h1><p>程序开发中数据结构可以分为这八类：<strong>数组、链表、栈、队列、散列表、树、堆、图</strong></p><table><thead><tr><th>类型</th><th>实现</th></tr></thead><tbody><tr><td>数组</td><td>ArrayList</td></tr><tr><td>链表</td><td>LinkedList</td></tr><tr><td>树</td><td>2-3树、红黑树</td></tr><tr><td>散列表</td><td>HashMap</td></tr><tr><td>栈</td><td>Stack</td></tr><tr><td>队列</td><td>Queue、Deque</td></tr></tbody></table><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081634845.png" alt="image-20220708163427762"></p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><blockquote><p>这是一个已经被抛弃的实现类，注意是实现类，并不是抛弃了这种数据结构</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The &lt;code&gt;Stack&lt;/code&gt; class represents a last-in-first-out</span><br><span class="hljs-comment"> * (LIFO) stack of objects. It extends class &lt;tt&gt;Vector&lt;/tt&gt; with five</span><br><span class="hljs-comment"> * operations that allow a vector to be treated as a stack. The usual</span><br><span class="hljs-comment"> * &lt;tt&gt;push&lt;/tt&gt; and &lt;tt&gt;pop&lt;/tt&gt; operations are provided, as well as a</span><br><span class="hljs-comment"> * method to &lt;tt&gt;peek&lt;/tt&gt; at the top item on the stack, a method to test</span><br><span class="hljs-comment"> * for whether the stack is &lt;tt&gt;empty&lt;/tt&gt;, and a method to &lt;tt&gt;search&lt;/tt&gt;</span><br><span class="hljs-comment"> * the stack for an item and discover how far it is from the top.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * When a stack is first created, it contains no items.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;A more complete and consistent set of LIFO stack operations is</span><br><span class="hljs-comment"> * provided by the &#123;<span class="hljs-doctag">@link</span> Deque&#125; interface and its implementations, which</span><br><span class="hljs-comment"> * should be used in preference to this class.  For example:</span><br><span class="hljs-comment"> * &lt;pre&gt;   &#123;<span class="hljs-doctag">@code</span></span><br><span class="hljs-comment"> * ✨ Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span><br><span class="hljs-comment"> * &#125;&lt;/pre&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Jonathan Payne</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Vector</span>&lt;E&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><ul><li>从上面源码的注释可以获取到，<code>Stack</code>栈是在<code>JDK1.0</code>的时代，基于继承<code>Vector</code>实现的本身<code>Vector</code>就是一个不被推荐使用的类，主要在于它的一些操作方法锁(<code>synchronized</code>)的力度太粗，都是放到方法上</li><li><code>Stack</code>栈底层是使用<code>Vector</code>数组实现，在学习<code>ArrayList</code>时候我们知道，数组结构在元素添加和删除需要通过<code>System.arraycopy</code>，进行扩容操作。而本身栈的特点就是首尾元素的操作，也不需要遍历，使用数组结构其实并不太理想</li><li>同是这个方法的注释也明确标出来，推荐使用<code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code>，虽然这也是数组结构，但是他没有粗粒度的锁，同时可以申请指定空间并且在扩容时也要优于<code>Stack</code>。并且这个还是一个双端队列，使用起来更加灵活</li></ul><h1 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h1><p><code>ArrayDeque </code>是基于数组实现的可动态扩容的双端队列，也就是说你可以在队列的头和尾同时插入和弹出元素。当元素数量超过数组初始化长度时，则需要扩容和迁移数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基于数组</span><br><span class="hljs-keyword">transient</span> Object[] elements; <span class="hljs-comment">// non-private to simplify nested class access</span><br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 带容量的初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> numElements)</span> &#123;<br>    allocateElements(numElements);<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateSize</span><span class="hljs-params">(<span class="hljs-type">int</span> numElements)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">initialCapacity</span> <span class="hljs-operator">=</span> MIN_INITIAL_CAPACITY;<br>    <span class="hljs-comment">// Find the best power of two to hold elements.</span><br>    <span class="hljs-comment">// Tests &quot;&lt;=&quot; because arrays aren&#x27;t kept full.</span><br>    <span class="hljs-keyword">if</span> (numElements &gt;= initialCapacity) &#123;<br>        initialCapacity = numElements;<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>);<br>        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>        initialCapacity++;<br><br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">// Too many elements, must back off</span><br>            initialCapacity &gt;&gt;&gt;= <span class="hljs-number">1</span>;<span class="hljs-comment">// Good luck allocating 2 ^ 30 elements</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> initialCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><p>在初始化的过程中，它需要找到你当前传输值最小的 2 的倍数的一个容量。这与 HashMap 的初始化过程相似</p><h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    elements[head = (head - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] = e;<br>    <span class="hljs-keyword">if</span> (head == tail)<br>        doubleCapacity();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    elements[tail] = e;<br>    <span class="hljs-keyword">if</span> ( (tail = (tail + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)) == head)<br>        doubleCapacity();<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分入栈元素，其实就是给数组赋值</p><ol><li><p>在 addFirst()中，定位下标，head &#x3D; (head - 1) &amp; (elements.length - 1)，因为我们的数组长度是 2^n 的倍数，所以 2^n - 1 就是一个全是 1 的二进制数，可以用于与运算得出数组下标。</p></li><li><p>同样 addLast()中，也使用了相同的方式定位下标，只不过它是从 0 开始，往上增加</p></li><li><p>最后，当头(head)与尾(tile)相等时，数组则需要两倍扩容 <code>doubleCapacity</code></p></li><li><p><code>head = 0;tail = n;</code>，head和tail在初始化时被赋的值，其实是占用了额外的一个格子去放头结点</p></li></ol><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doubleCapacity</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">assert</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span>= tail;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> elements.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n - p; <span class="hljs-comment">// number of elements to the right of p</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> n &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Sorry, deque too big&quot;</span>);<br>    Object[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newCapacity];<br>    System.arraycopy(elements, p, a, <span class="hljs-number">0</span>, r);<br>    System.arraycopy(elements, <span class="hljs-number">0</span>, a, r, p);<br>    elements = a;<br>    head = <span class="hljs-number">0</span>;<br>    tail = n;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实以上这部分源码，就是进行两倍<code>n &lt;&lt; 1</code>扩容，同时把两端数据迁移进新的数组</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p><code>Linkedlist</code>天生就可以支持双端队列，而且从头尾取数据也是它时间复杂度 O(1)的。同时数据的插入和删除也不需要像数组队列那样拷贝数据，虽然 <code>Linkedlist</code>有这些优点，但不能说 <code>ArrayDeque </code>因为有数组复制性能比它低</p><p><code>LinkedList</code>在功能体现上和<code>ArrayDeque</code>是差不多的</p><h2 id="入栈、出栈源码"><a href="#入栈、出栈源码" class="headerlink" title="入栈、出栈源码"></a>入栈、出栈源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f);<br>    first = newNode;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        last = newNode;<br>    <span class="hljs-keyword">else</span><br>        f.prev = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个方法分别是给链表的首尾节点插入元素，因为这是链表结构，所以也不存在扩容，只需要把双向链路链接上即可</p><h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><p>在 <code>Java </code>的队列数据结构中，还有一种队列是延时队列，可以通过设定存放时间，依次轮训获取</p><p>DelayQueue 是一个 BlockingQueue （无界阻塞）队列，它本质就是封装了一个 PriorityQueue （优先级队列），并加上了延时功能。可以这么说，DelayQueue 就是一个使用优先队列（PriorityQueue）实现的 BlockingQueue，优先队列的比较基准值是时间</p><p>即：<strong>DelayQueue &#x3D; BlockingQueue + PriorityQueue + Delayed</strong></p><p>要实现 DelayQueue 延时队列，队中元素要 implements Delayed 接口，这个接口里只有一个 getDelay 方法，用于设置延期时间。Delayed 由实现了 Comparable 接口， compareTo 方法负责对队列中的元素进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDelayed</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String str;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestDelayed</span><span class="hljs-params">(String str, <span class="hljs-type">long</span> time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.str = str;<br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + (time &gt; <span class="hljs-number">0</span> ? unit.toMillis(time) : <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> time - System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>        <span class="hljs-type">TestDelayed</span> <span class="hljs-variable">work</span> <span class="hljs-operator">=</span> (TestDelayed) o;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.time - work.time;<br>        <span class="hljs-keyword">if</span> (diff &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStr</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_DelayQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    DelayQueue&lt;TestDelayed&gt; delayQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;TestDelayed&gt;();<br>    delayQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestDelayed</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS));<br>    delayQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestDelayed</span>(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS));<br>    delayQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestDelayed</span>(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS));<br><br>    logger.info(((TestDelayed) delayQueue.take()).getStr());<br>    logger.info(((TestDelayed) delayQueue.take()).getStr());<br>    logger.info(((TestDelayed) delayQueue.take()).getStr());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// ReentrantLock 可重入锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        q.offer(e);<br>        <span class="hljs-keyword">if</span> (q.peek() == e) &#123;<br>            leader = <span class="hljs-literal">null</span>;<br>            available.signal();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br>------PriorityQueue.java-----------<br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue[parent];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        k = parent;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>DelayQueue </code>是基于数组实现的，所以可以动态扩容，另外它插入元素的顺序并不影响最终的输出顺序。</li><li>而元素的排序依赖于 <code>compareTo </code>方法进行排序，也就是休眠的时间长短决定的。</li><li>同时只有实现了 <code>Delayed </code>接口，才能存放元素。</li></ul><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> q.peek();<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>)<br>                available.await();<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> q.poll();<br>                first = <span class="hljs-literal">null</span>; <span class="hljs-comment">// don&#x27;t retain ref while waiting</span><br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>)<br>                    available.await();<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                    leader = thisThread;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        available.awaitNanos(delay);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; q.peek() != <span class="hljs-literal">null</span>)<br>            available.signal();<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其它队列"><a href="#其它队列" class="headerlink" title="其它队列"></a>其它队列</h1><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081954303.png" alt="image-20220708195416153"></p><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207081954758.png" alt="image-20220708195432687"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataQueueStack</span> &#123;<br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;DataBean&gt; dataQueue = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DataQueueStack</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//实例化队列</span><br>        dataQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;DataBean&gt;(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加数据到队列</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataBean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doOfferData</span><span class="hljs-params">(DataBean dataBean)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> dataQueue.offer(dataBean, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 弹出队列数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> DataBean <span class="hljs-title function_">doPollData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> dataQueue.poll(<span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得队列数据个数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doGetQueueCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dataQueue.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这是一个 <code>LinkedBlockingQueue </code>队列使用案例，一方面存储数据，一方面从队列中获取进行消费。</li><li>因为这是一个阻塞队列，所以在获取元素的时候，如果队列为空，会进行阻塞。</li><li><code>LinkedBlockingQueue </code>是一个阻塞队列，内部由两个 <code>ReentrantLock </code>来实现出入队列的线程安全，由各自的 <code>Condition </code>对象的 <code>await </code>和 <code>signal </code>来实现等待和唤醒功能</li></ul>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标题</title>
    <link href="/2022/07/07/2022-1-1-%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/07/07/2022-1-1-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>content</p>]]></content>
    
    
    <categories>
      
      <category>分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="/2022/07/07/2022-7-7-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/07/2022-7-7-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">// DEFAULTCAPACITY_EMPTY_ELEMENTDATA 已经被提前定义好了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; <br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>通常情况空构造函数初始化ArrayList更常用，这种方式数组的长度会在以一次插入数据时候进行设置</li><li>第二种情况，当我们已近知道要填入多少个元素到ArrayList中了，那么这个时候哈就可以直接初始化一个预先设定好的长度，以达到提供性能，减少ArrayList中的拷贝操作，当然这种情况下数组的长度依旧会在以一次插入数据时候进行设置</li></ul><h2 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a>Arrays.asList</h2><p>通过 <code>Arrays.asList</code> 传递给 <code>ArrayList </code>构造函数的方式进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过构造函数可以看到，只要实现 Collection 类的都可以作为入参</li><li>在通过转为数组以及拷贝 Arrays.copyOf 到 Object[]集合中在赋值给属性elementData</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; list1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;通过数组转换：&quot;</span> + (list1.toArray().getClass() == Object[].class));<br>    <br>    ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>    System.out.println(<span class="hljs-string">&quot;通过集合转换：&quot;</span> + (list2.toArray().getClass() == Object[].class));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">通过数组转换：false</span><br><span class="hljs-comment">通过集合转换：true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>public Object[] toArray()</code> 返回的类型不一定就是 <code>Object[]</code>，其类型取决于其返回的实际类型，毕竟 <code>Object </code>是父类，它可以是其他任意类型</p><p>子类实现和父类同名的方法，仅仅返回值不一致时，默认调用的是子类的实现方法</p><p>造成这个结果的原因，如下；</p><ol><li><code>Arrays.asList</code> 使用的是：<code>Arrays.copyOf(this.a, size,(Class&lt;? extends T[]&gt;) a.getClass());</code></li><li><code>ArrayList</code> 构造函数使用的是：<code>Arrays.copyOf(elementData, size, Object[].class);</code></li></ol><hr><ul><li>Arrays.asList 构建的集合，不能赋值给 ArrayList</li><li>Arrays.asList 构建的集合，不能再添加元素</li><li>Arrays.asList 构建的集合，不能再删除元素</li></ul><blockquote><p>在官方文档就已经说明返回的是一个固定大小的集合</p></blockquote><p>其实造成上面结果的原因是这两个<code>List</code>不是同一个东西，而且<code>Arrays</code>下的<code>ArrayList</code>是一个私有类，只能通过asList使用，不能单独创建</p><p>这个ArrayList不能添加和删除，主要是因为它的实现方式，内部是一个数组</p><blockquote><p><code>Arrays </code>是一个工具包，里面还有一些非常好用的方法，例如；二分查找<code>Arrays.binarySearch</code>、排序 <code>Arrays.sort</code> 等</p></blockquote><h2 id="Collections-ncopies"><a href="#Collections-ncopies" class="headerlink" title="Collections.ncopies"></a>Collections.ncopies</h2><p><code>Collections.nCopies</code> 是集合方法中用于生成多少份某个指定元素的方法，接下来就用它来初始化 ArrayList，如下；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(Collections.nCopies(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><blockquote><p>这会初始化一个由 10 个 0 组成的集合</p></blockquote><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><h2 id="普通插入"><a href="#普通插入" class="headerlink" title="普通插入"></a>普通插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Appends the specified element to the end of this list.</span><br><span class="hljs-comment">   将指定元素附加到此列表的末尾</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    modCount++;<br>    add(e, elementData, size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入时扩容"><a href="#插入时扩容" class="headerlink" title="插入时扩容"></a>插入时扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    rangeCheckForAdd(index);<br>    modCount++;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> s;<br>    Object[] elementData;<br>    <span class="hljs-keyword">if</span> ((s = size) == (elementData = <span class="hljs-built_in">this</span>.elementData).length)<br>        elementData = grow();<br>    System.arraycopy(elementData, index,<br>                     elementData, index + <span class="hljs-number">1</span>,<br>                     s - index);<br>    elementData[index] = element;<br>    size = s + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    Objects.checkIndex(index, size);<br>    <span class="hljs-keyword">final</span> Object[] es = elementData;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> (E) es[index];<br>    fastRemove(es, index);<br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(Object[] es, <span class="hljs-type">int</span> i)</span> &#123;<br>    modCount++;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> newSize;<br>    <span class="hljs-keyword">if</span> ((newSize = size - <span class="hljs-number">1</span>) &gt; i)<br>        System.arraycopy(es, i + <span class="hljs-number">1</span>, es, i, newSize - i);<br>    es[size = newSize] = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2022/07/06/2022-7-6-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/06/2022-7-6-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h1><ul><li><p>HashMap最早出现在JDK1.2中,底层基于散列算法实现</p></li><li><p>HashMap允许nul键和null值</p></li><li><p>HashMap并不保证键值对的顺序</p></li><li><p>HashMap是非线程安全的</p></li><li><p>等等…</p></li></ul><blockquote><p>在JDK1.7时,HashMap采用的是数组+链表,但是在JDK1.8的时候,HashMap采用的是数组加{链表或红黑树}</p></blockquote><h1 id="初步了解HashMap"><a href="#初步了解HashMap" class="headerlink" title="初步了解HashMap"></a>初步了解HashMap</h1><blockquote><p>从根源去看,如果说我们现在有一堆字符串,我想要将他存在一个数组中,并要求获取每个元素的时间复杂度是O(1),这个时候就可以使用HashMap</p></blockquote><p>我们只需要通过某种方式去计算单个字符的索引下标即可,就像下面这样</p><p>其中<code>key.hashCode() &amp; (tab.length - 1)</code>其实就是<code>key.hashCode()</code>对8进行取余</p><blockquote><p>记x为2的幂次方</p><p>这个&amp;运算取余的操作只适用于对x这样的进行操作,就是&amp;一个2的幂次方 - 1,就等同于对x进行取余</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义要存放的数组</span><br>String[] tab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">8</span>];<br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br><span class="hljs-comment">// 计算索引位置</span><br><span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> key.hashCode() &amp; (tab.length - <span class="hljs-number">1</span>);  <br>tab[idx] = key;<br></code></pre></td></tr></table></figure><h1 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h1><blockquote><p>顾名思义,该函数是为了增加随机性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>从上面可以看出<code>hashCode</code>的返回值是<code>int</code>类型,也就是二进制是32位,那么此时<code>hashCode</code>的取值范围是[-2147483648, 2147483647],长度很大,在初始化数组时候不会去将数组初始化这么大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment"> ===容量必须是2的幂,[2,4,8,16,32...]===</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br></code></pre></td></tr></table></figure><p>可以看到,初始化的时候,会将这个数组长度初始化为16,但是我们获得的<code>hashcode</code>是32位,不能直接使用,所以需要对数组的长度进行取模得到下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>hashMap</code>源码这里不只是直接获取哈希值,还进行了一次扰动计算,<code>(h =key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>.把哈希值右移 16 位,也就正好是自己长度的一半,之后与原哈希值做异或运算,这样就混合了原哈希值中的高位和低位,增大了随机性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">00000000001011</span> <span class="hljs-number">1011001101000110</span>  <span class="hljs-comment">//  初始  &quot;小赵&quot;.hashCode()</span><br><span class="hljs-number">00000000000000</span> <span class="hljs-number">0000000000001011</span>  <span class="hljs-comment">//  &gt;&gt;&gt; 16</span><br><span class="hljs-number">00000000001011</span> <span class="hljs-number">1011001101001101</span>  <span class="hljs-comment">//  ^</span><br></code></pre></td></tr></table></figure><p>观察仔细的话,还可以发现<code>(key == null) ? 0  : (h </code>,说明<code>HashMap</code>可以<code>key</code>为<code>null</code>,且此时的<code>hash</code>值为0</p><ul><li>使用扰动函数就是为了增加随机性,让数据元素更加均衡的散列,减少碰撞</li></ul><h1 id="初始化容量和负载因子"><a href="#初始化容量和负载因子" class="headerlink" title="初始化容量和负载因子"></a>初始化容量和负载因子</h1><h2 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h2><p>可以先看下面这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  initialCapacity 初始化容量</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span>  loadFactor      负载因子</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    ...<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity); <span class="hljs-comment">// 阈值</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>阀值 <code>threshold</code>,通过方法 <code>tableSizeFor </code>进行计算,是根据初始化来计算的</li><li>这个方法也就是要寻找比初始值大的,最小的那个2<code>进制</code>数值.比如传了<code>17</code>,我应该找到的是<code>32</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算阈值大小的方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>; <br></code></pre></td></tr></table></figure><p>这个地方计算阈值是先要将<code>cap-1</code>,再将他最高位往下全部变成<code>1</code>(<code>1111111</code>),最后再<code>cap+1</code>,会变成<code>1000000</code>这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始值我们用 17   -&gt;    17 - 1  =  16</span><br><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-comment">// n |= n &gt;&gt;&gt; 1;</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-comment">// n |= n &gt;&gt;&gt; 2;</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-comment">// n |= n &gt;&gt;&gt; 4;</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-comment">// n |= n &gt;&gt;&gt; 8;</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>   <span class="hljs-comment">// n |= n &gt;&gt;&gt; 16;</span><br><span class="hljs-comment">// 最后+1</span><br><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><span class="hljs-comment">// 32    </span><br></code></pre></td></tr></table></figure><h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br></code></pre></td></tr></table></figure><p>所以,要选择一个合理的大小下进行扩容,默认值 0.75 就是说当阀值容量占了3&#x2F;4 时赶紧扩容,减少 Hash 碰撞</p><p>同时 0.75 是一个默认构造值,在创建 HashMap 也可以调整,比如你希望用更多的空间换取时间,可以把负载因子调的更小一些,减少碰撞</p><h1 id="扩容元素拆分"><a href="#扩容元素拆分" class="headerlink" title="扩容元素拆分"></a>扩容元素拆分</h1><p>这个地方可以举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_hashMap</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;jlkk&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;lopi&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;jmdw&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;e4we&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;io98&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;nmhg&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;vfg6&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;gfrt&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;alpo&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;vfbh&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;bnhj&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;zuio&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;iu8e&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;yhjk&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;plop&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;dd0p&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (String key : list) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符串:&quot;</span> + key + <span class="hljs-string">&quot; \tIdx(16):&quot;</span> + ((<span class="hljs-number">16</span> - <span class="hljs-number">1</span>) &amp; hash) + <span class="hljs-string">&quot; \tBit值:&quot;</span> + Integer.toBinaryString(hash) + <span class="hljs-string">&quot; - &quot;</span> + Integer.toBinaryString(hash &amp; <span class="hljs-number">16</span>) + <span class="hljs-string">&quot; \t\tIdx(32):&quot;</span> + ((<span class="hljs-number">32</span> - <span class="hljs-number">1</span>) &amp; hash));<br>        System.out.println(Integer.toBinaryString(key.hashCode()) +<span class="hljs-string">&quot; &quot;</span>+ Integer.toBinaryString(hash) + <span class="hljs-string">&quot; &quot;</span> + Integer.toBinaryString((<span class="hljs-number">32</span> - <span class="hljs-number">1</span>) &amp; hash));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽取两条内容出来</span><br>字符串:jlkk <span class="hljs-title function_">Idx</span><span class="hljs-params">(<span class="hljs-number">16</span>)</span>:<span class="hljs-number">3</span> Bit 值:<span class="hljs-number">1100011101001000010011</span> - <span class="hljs-number">10000</span> Idx(<span class="hljs-number">32</span>):<span class="hljs-number">19</span><br>hashcoded1100011101001000100010 <span class="hljs-number">1100011101001000010011</span> <span class="hljs-number">10011</span><br>    <br>字符串:lopi <span class="hljs-title function_">Idx</span><span class="hljs-params">(<span class="hljs-number">16</span>)</span>:<span class="hljs-number">14</span> Bit 值:<span class="hljs-number">1100101100011010001110</span> - <span class="hljs-number">0</span> Idx(<span class="hljs-number">32</span>):<span class="hljs-number">14</span><br><span class="hljs-number">1100101100011010111100</span> <span class="hljs-number">1100101100011010001110</span> <span class="hljs-number">1110</span><br></code></pre></td></tr></table></figure><p>可以先找规律的去看</p><p>当容量为16时,对应的坐标是3和14,<code>(16 - 1) &amp; hash</code></p><p>可以注意到<code>hash &amp; 16</code>分别是<code>10000</code>和<code>0</code>,16对应的二进制是<code>10000</code>,所以一个数和他相与,得出来的要么是<code>10000</code>,要么是<code>0</code></p><p><strong>如果是<code>0</code></strong>,是不是就代表着<code>hash</code>这一位上是<code>0</code>,可以推出<code>(32 - 1) &amp; hash </code> &#x3D;&#x3D; <code>(16 - 1) &amp; hash</code> ,也就是位置并没有发生改变</p><p><strong>同理可以推出不是<code>0</code>的话</strong>,我们可以让一开始求得的下标加上<code>16</code>,就得到新的扩容后的坐标了</p><blockquote><p>这个地方设计的非常巧妙</p></blockquote><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><h2 id="插入源码"><a href="#插入源码" class="headerlink" title="插入源码"></a>插入源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// hash(key) 进行了hash扰动</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>); <br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 初始化桶数组 table,table 被延迟到插入新数据时再进行初始化</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 如果桶中不包含键值对节点引用,则将新键值对节点的引用存入桶中即可</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 如果键的值以及节点 hash 等于链表中的第一个键值对节点时,则将 e 指向该键值对</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 如果桶中的引用类型为 TreeNode,则调用红黑树的插入方法</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对链表进行遍历,并统计链表长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 链表中不包含要插入的键值对节点时,则将该节点接在链表的最后</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 如果链表长度大于或等于树化阈值,则进行树化操作</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 条件为 true,表示当前链表包含要插入的键值对,终止遍历</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 判断要插入的键值对是否存在 HashMap 中</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue; <span class="hljs-comment">// 因为是替换value,所以不需要去判断容量,直接返回结果</span><br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 键值对数量超过阈值时,则进行扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩容源码"><a href="#扩容源码" class="headerlink" title="扩容源码"></a>扩容源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// Cap 是 capacity 的缩写,容量.如果容量不为空,则说明已经初始化</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果容量达到最大 1 &lt;&lt; 30 则不再扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 按旧容量和阀值的 2 倍计算新容量和阀值</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <br>    <span class="hljs-comment">// initial capacity was placed in threshold 翻译过来的意思,如下;</span><br>    <span class="hljs-comment">// 初始化时,将 threshold 的值赋值给 newCap,</span><br>    <span class="hljs-comment">// HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        <span class="hljs-comment">// 这一部分也是,源代码中也有相应的英文注释</span><br>        <span class="hljs-comment">// 调用无参构造方法时,数组桶数组容量为默认容量 1 &lt;&lt; 4; aka 16</span><br>        <span class="hljs-comment">// 阀值;是默认容量与负载因子的乘积,0.75</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <br>    <span class="hljs-comment">// newThr 为 0,则使用阀值公式计算容量</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    <br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    <span class="hljs-comment">// 初始化数组桶,用于存放 key</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <span class="hljs-comment">// 如果旧数组桶,oldCap 有值,则遍历将键值映射到新数组桶中</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 这里 split,是红黑树拆分操作.在重新映射时操作的.</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">// 这里是链表,如果当前是按照链表存放的,则将链表节点按原顺序进行分组</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <br>                    <span class="hljs-comment">// 将分组后的链表映射到桶中</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h2><blockquote><p>在jdk1.8之前,采用的都是链表方式存放数据,但是这样从链表中取数据的时间复杂度就是O(n),链表越长性能越差,因此在jdk1.8中把过长的链表,也就是8个,优化成自平衡的红黑树结构,以此让定位元素的时间复杂度优化近似O(logn)</p><p>但也并不是完全抛弃了链表,因为在元素相对不多的情况下,链表的插入速度更快,所以总会考虑设定阈值为8才进行红黑树转换操作</p></blockquote><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207071029357.png" alt="image-20220707102944268"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 不一定树化还可能只是扩容.主要桶数组容量是否小于64 MIN_TREEIFY_CAPACITY</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 将普通节点转换为树节点,但此时还不是红黑树,也就是说还不一定平衡</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">// 转红黑树操作</span><br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>链表树化的条件:1.链表长度大于等于8,桶容量大于64,否则只是扩容,不会树化</li><li>链表树化的过程中是吸纳由链表转换为树节点,此时的树并不是一颗平衡树,同时在此过程中会<strong>记录链表的顺序</strong>,这主要方便后序转链表和拆分更加方便</li></ul><h2 id="红黑树转链表"><a href="#红黑树转链表" class="headerlink" title="红黑树转链表"></a>红黑树转链表</h2><p>链表转红黑树的过程中,记录了原有链表的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">untreeify</span><span class="hljs-params">(HashMap&lt;K,V&gt; map)</span> &#123;<br>    Node&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 遍历 TreeNode</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; q = <span class="hljs-built_in">this</span>; q != <span class="hljs-literal">null</span>; q = q.next) &#123;<br>        <span class="hljs-comment">// TreeNode 替换 Node</span><br>        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>            hd = p;<br>        <span class="hljs-keyword">else</span><br>            tl.next = p;<br>        tl = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hd;<br>&#125;<br><br><span class="hljs-comment">// 替换方法</span><br>Node&lt;K,V&gt; <span class="hljs-title function_">replacementNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为记录了链表关系,所以替换过程很容易.所以好的数据结构可以让操作变得更加容易</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 同样需要经过扰动函数计算哈希值</span><br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-comment">// 判断桶数组的是否为空和长度值</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-comment">// 计算下标,哈希值与数组长度-1</span><br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// TreeNode 节点直接调用红黑树的查找方法,时间复杂度 O(logn)</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 如果是链表就依次遍历查找</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) == <span class="hljs-literal">null</span> ?<br>        <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">removeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key, Object value,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> matchValue, <span class="hljs-type">boolean</span> movable)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, index;<br>    <span class="hljs-comment">// 定位桶数组中的下标位置,index = (n - 1) &amp; hash</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-literal">null</span>, e; K k; V v;<br>        <span class="hljs-comment">// 如果键的值与链表第一个节点相等,则将 node 指向该节点</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 树节点,调用红黑树的查找方法,定位节点</span><br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 遍历链表,找到待删除节点</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 删除节点,以及红黑树需要修复,因为删除后会破坏平衡性.链表的删除更加简单</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-built_in">this</span>, tab, movable);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="添加元素-在-HashMap-还是只链表结构时"><a href="#添加元素-在-HashMap-还是只链表结构时" class="headerlink" title="添加元素,在 HashMap 还是只链表结构时"></a>添加元素,在 HashMap 还是只链表结构时</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207072008336.png" alt="image-20220707200846170"></p><h2 id="添加元素-在-HashMap-转换为红黑树时候"><a href="#添加元素-在-HashMap-转换为红黑树时候" class="headerlink" title="添加元素,在 HashMap 转换为红黑树时候"></a>添加元素,在 HashMap 转换为红黑树时候</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207072008827.png" alt="image-20220707200829678"></p><h2 id="删除元素-在-HashMap-转换为链表结构时"><a href="#删除元素-在-HashMap-转换为链表结构时" class="headerlink" title="删除元素,在 HashMap 转换为链表结构时"></a>删除元素,在 HashMap 转换为链表结构时</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207072008360.png" alt="image-20220707200837192"></p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖的技术总结</title>
    <link href="/2022/07/05/2022-7-5-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/"/>
    <url>/2022/07/05/2022-7-5-%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96/</url>
    
    <content type="html"><![CDATA[<h1 id="WebMVC"><a href="#WebMVC" class="headerlink" title="WebMVC"></a>WebMVC</h1><h2 id="消息转化器"><a href="#消息转化器" class="headerlink" title="消息转化器"></a>消息转化器</h2><blockquote><p>将后端返回给前端的对象转换为json,对long数据转换,日期等</p></blockquote><p>使用Mapper文件夹替代Dao</p><p>同时使用<code>@Mapper</code>注解而不是<code>@Repository</code>注解</p><blockquote><p>两者区别:</p><p>@Repository是spring的注解,标记为一个bean,配合mybatis时需要配置@MapperScan</p><p>@Mapper是Mybatis的注解,不需要额外的@MapperScan扫描</p></blockquote><h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h1><h2 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a>LambdaQueryWrapper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>queryWrapper.eq(Employee::getName,employee.getUsername());<br><span class="hljs-type">Employee</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> employeeService.getOne(queryWrapper);<br></code></pre></td></tr></table></figure><h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置MP的分页插件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">mybatisPlusInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>());<br>        <span class="hljs-keyword">return</span> mybatisPlusInterceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 员工信息分页查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page, <span class="hljs-type">int</span> pageSize, String name)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;page = &#123;&#125;,pageSize = &#123;&#125;,name = &#123;&#125;&quot;</span>,page,pageSize,name);<br><br>    <span class="hljs-comment">// 构造分页构造器</span><br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pageInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(page,pageSize);<br><br>    <span class="hljs-comment">// 构造条件构造器</span><br>    LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>();<br>    <span class="hljs-comment">// 添加过滤条件</span><br>    queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);<br>    <span class="hljs-comment">// 添加排序条件</span><br>    queryWrapper.orderByDesc(Employee::getUpdateTime);<br><br>    <span class="hljs-comment">// 执行查询</span><br>    employeeService.page(pageInfo,queryWrapper); <span class="hljs-comment">// 不需要返回,传进去就构造好了</span><br>    <span class="hljs-keyword">return</span> R.success(pageInfo);<br>&#125;<br></code></pre></td></tr></table></figure><p>前端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMemberList</span> (params) &#123;<br>  <span class="hljs-keyword">return</span> $axios(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/employee/page&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    params<br>  &#125;)<br>&#125;<br><br>不过在前端有个拦截器<br>会将传过去的路劲改变<br></code></pre></td></tr></table></figure><h2 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h2><p>在实体类属性上加注解<code>@TableField</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span> <span class="hljs-comment">// 插入时填充字段</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> <span class="hljs-comment">// 插入和更新时填充字段</span><br><span class="hljs-keyword">private</span> LocalDateTime updateTime;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> Long createUser;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> Long updateUser;<br></code></pre></td></tr></table></figure><p>创建<strong>MyMetaObjectHandler</strong>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;公共字段自动填充[insert]...&quot;</span>);<br>        log.info(metaObject.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;公共字段自动填充[update]...&quot;</span>);<br>        log.info(metaObject.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用ThreadLocal进行完善</p><hr><h1 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">employee.setPassword(DigestUtils.md5DigestAsHex(<span class="hljs-string">&quot;123456&quot;</span>.getBytes()));<br></code></pre></td></tr></table></figure><h1 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h1><p>commons-fileupload</p><p>commons-io</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件上传和下载</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/common&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String basePath;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件上传</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span> &#123; <span class="hljs-comment">// 参数名字和前端的名字一致</span><br>        log.info(file.toString());<br><br>        <span class="hljs-comment">// 原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">// 使用UUID重新生成文件名,防止文件名重复造成文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + suffix;<br><br>        <span class="hljs-comment">// 创建一个目录对象</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(basePath);<br>        <span class="hljs-comment">// 判断当前目录是否存在</span><br>        <span class="hljs-keyword">if</span> (!dir.exists()) &#123;<br>            <span class="hljs-comment">// 目录不存在,需要创建</span><br>            dir.mkdirs();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            file.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(basePath + fileName));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> R.success(fileName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件下载</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/download&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">download</span><span class="hljs-params">(String name, HttpServletResponse response)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 输入流,通过出入刘读取文件内容</span><br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(basePath + name));<br><br>            <span class="hljs-comment">// 输出流,通过输出流将文件写回浏览器,在浏览器展示图片了</span><br>            <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>            response.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>                outputStream.write(bytes,<span class="hljs-number">0</span>,len);<br>                outputStream.flush();<br>            &#125;<br><br>            <span class="hljs-comment">// 关闭资源</span><br>            outputStream.close();<br>            fileInputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="关闭8080端口"><a href="#关闭8080端口" class="headerlink" title="关闭8080端口"></a>关闭8080端口</h1><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202206271443914.png" alt="image-20220627144344849"></p><h1 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h1><blockquote><p>基于注解的缓存功能</p></blockquote><table><thead><tr><th>@EnableCaching</th><th>开启缓存注解</th></tr></thead><tbody><tr><td>@cacheable</td><td>查询缓存,将方法缓存值放入缓存池中</td></tr><tr><td>@Cacheput</td><td>插入缓存</td></tr><tr><td>@CacheEvict</td><td>删除缓存</td></tr></tbody></table><p><strong>导坐标</strong></p><p>只是使用基础功能(基于Mysql),不需要导包,已经存在于<code>spring-context</code>中了</p><p><strong>扩展坐标</strong></p><p><code>Spring-cache</code>坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>redis</code>坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>配置redis<code>application.yml</code></strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cache:</span><br>    <span class="hljs-attr">redis:</span><br>      <span class="hljs-attr">time-to-live:</span> <span class="hljs-number">180000</span> <span class="hljs-comment">#设置缓存有效期</span><br></code></pre></td></tr></table></figure><p><strong>开启缓存注解功能</strong></p><p>在启动类上加<code>@EnableCaching</code>开启</p><h1 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h1><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207031527152.png" alt="image-20220703152704036"></p><p><strong>主库Master</strong></p><p>第一步修改Msyql配置文件 <code>/etc/my.cnf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cnf">[mysqld]<br>server_id=100 ## 设置server_id,同一局域网中需要唯一ID<br>log-bin=mysql-bin ## 开启二进制日志功能,以备Slave作为其它数据库实例的Master时使用<br></code></pre></td></tr></table></figure><p>开启远程权限</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">replication</span> slave <span class="hljs-keyword">on</span> *.* <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;xiaoming&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;root@123456&#x27;</span>;<br><br># 更改密码策略<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> validate_password_policy=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">show <span class="hljs-keyword">master</span> <span class="hljs-title">status</span>;<br></code></pre></td></tr></table></figure><p><strong>从库Slave</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">server_id</span>=<span class="hljs-number">101</span> <span class="hljs-comment">## 设置server_id,同一局域网中需要唯一ID</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">change master <span class="hljs-keyword">to</span><br>    <span class="hljs-attribute">MASTER_HOST</span>=<span class="hljs-string">&#x27;192.168.33.131&#x27;</span>,<br>    <span class="hljs-attribute">MASTER_USER</span>=<span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>    <span class="hljs-attribute">MASTER_PASSWORD</span>=<span class="hljs-string">&#x27;root@123456&#x27;</span>,<br>    <span class="hljs-attribute">MASTER_LOG_FILE</span>=<span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>,<br>    <span class="hljs-attribute">MASTER_LOG_POS</span>=1833;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 启动从库同步开关</span><br><span class="hljs-literal">start</span> <span class="hljs-literal">slave</span>;<br><span class="hljs-literal">stop</span> <span class="hljs-literal">slave</span> <span class="hljs-comment"># 停止</span><br>    <br><span class="hljs-comment"># 检查状态</span><br>show <span class="hljs-literal">slave</span> status\G<br>    <br> <br><span class="hljs-comment"># 需要下面全部变成yes</span><br>Slave_IO_Running: YES <span class="hljs-comment"># 没变是因为UUID</span><br>Slave_SQL_Running: YES<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_46049759/article/details/116779743">参考个人博客</a></p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><p><strong>导包</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0-RC1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在配置文件中配置读写分离规则</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment"># 应用名称</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">reggie_take_out</span><br>  <span class="hljs-attr">shardingsphere:</span><br>    <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">names:</span><br>        <span class="hljs-string">master,slave</span><br>      <span class="hljs-comment"># 主数据源</span><br>      <span class="hljs-attr">master:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://192.168.33.131:3306/reggie?characterEncoding=utf-8</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>      <span class="hljs-comment"># 从数据源</span><br>      <span class="hljs-attr">slave:</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>        <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://192.168.3.132:3306/reggie?characterEncoding=utf-8</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">masterslave:</span><br>      <span class="hljs-comment"># 读写分离配置</span><br>      <span class="hljs-attr">load-balance-algorithm-type:</span> <span class="hljs-string">round_robin</span> <span class="hljs-comment">#轮询</span><br>      <span class="hljs-comment"># 最终的数据源名称</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">dataSource</span><br>      <span class="hljs-comment"># 主库数据源名称</span><br>      <span class="hljs-attr">master-data-source-name:</span> <span class="hljs-string">master</span><br>      <span class="hljs-comment"># 从库数据源名称列表,多个逗号分隔</span><br>      <span class="hljs-attr">slave-data-source-names:</span> <span class="hljs-string">slave</span><br>    <span class="hljs-attr">props:</span><br>      <span class="hljs-attr">sql:</span><br>        <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启SQL显示,默认false</span><br></code></pre></td></tr></table></figure><p><strong>在配置文件汇总配置被允许bean定义覆盖配置项</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">main:</span><br>        <span class="hljs-attr">allow-bean-definition-overriding:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><hr><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>轻量web服务器,反向代理服务器,邮件代理服务器,占有内存小,并发能力强<br><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p><p>本文基于<code>Centos7</code>去安装</p></blockquote><p><strong>安装依赖包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装gcc 如果没有yum源,可以参考下面博客链接去配置</span><br>apt-get install yum<br><br>yum install --nogpgcheck  gcc pcre-devel zlib-devel openssl openssl-devel<br></code></pre></td></tr></table></figure><p><strong>下载Nginx安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装wget</span><br>apt-get install wget<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载nginx</span><br>wget http://nginx.org/download/nginx-1.16.1.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压文件</span><br>tar -zxvf nginx-1.16.1.tar.gz -C /soft<br></code></pre></td></tr></table></figure><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入解压目录/soft  创建安装文件夹nginx  然后在安装</span><br>./configure --prefix=/usr/local/nginx<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">=====出现下面信息代表初步安装检查完成=====<br>checking for PCRE JIT support ... found<br>checking for zlib library ... found<br>creating objs/Makefile<br><br>Configuration summary<br>  + using system PCRE library<br>  + OpenSSL library is not used<br>  + using system zlib library<br><br>  nginx path prefix: &quot;/usr/local/nginx&quot;<br>  nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot;<br>  nginx modules path: &quot;/usr/local/nginx/modules&quot;<br>  nginx configuration prefix: &quot;/usr/local/nginx/conf&quot;<br>  nginx configuration file: &quot;/usr/local/nginx/conf/nginx.conf&quot;<br>  nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;<br>  nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;<br>  nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;<br>  nginx http client request body temporary files: &quot;client_body_temp&quot;<br>  nginx http proxy temporary files: &quot;proxy_temp&quot;<br>  nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;<br>  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;<br>  nginx http scgi temporary files: &quot;scgi_temp&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">make &amp;&amp; make install<br>------真正安装完成<br>|| mkdir -p &#x27;/usr/local/nginx/logs&#x27;<br>make[1]: Leaving directory `/root/nginx-1.16.1&#x27;<br></code></pre></td></tr></table></figure><p>报错1:<a href="https://www.cnblogs.com/zhoading/p/9938762.html">https://www.cnblogs.com/zhoading/p/9938762.html</a></p><p><strong>查看版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost sbin]# ./nginx -v<br>nginx version: nginx/1.16.1<br></code></pre></td></tr></table></figure><p><strong>开始前测试</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost sbin]# ./nginx -t<br>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful<br></code></pre></td></tr></table></figure><p><strong>启动和停止</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>./nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止</span><br>./nginx -s stop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看进程</span><br>ps -ef | grep nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重写加载配置文件</span><br>./nginx -s reload<br>------------------------------------------------------------------------<br>root       8460      1  0 12:03 ?        00:00:00 nginx: master process ./nginx<br>nobody     8461   8460  0 12:03 ?        00:00:00 nginx: worker process<br>root       8616   8008  0 12:04 pts/0    00:00:00 grep --color=auto nginx<br>------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开/关防火墙</span><br>service firewalld restart 重启<br>service firewalld start 开启<br>service firewalld stop 关闭<br></code></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207041419539.png" alt="image-20220704141950432"></p><h2 id="部署静态资源"><a href="#部署静态资源" class="headerlink" title="部署静态资源"></a>部署静态资源</h2><blockquote><p>更为高效</p></blockquote><p><code>nginx.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>      listen       80;# 监听端口<br>      server_name  localhost;# 服务名称<br>      <br>      location / &#123;# 匹配客户端请求url<br>          root   html;# 指定静态资源根目录<br>          index  index.html;# 指定默认首页<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><code>nginx.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>      listen       82;# 监听端口<br>      server_name  localhost;# 服务名称<br>      <br>      location / &#123;# 匹配客户端请求url<br>      proxy_passhttp://192.168.138.101:8080; # 反向代理配置,将请求转发到指定服务<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://sansisuifeng-img.oss-cn-beijing.aliyuncs.com/img/202207041542371.png" alt="image-20220704154233304"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote><p>基于反向代理实现</p><p>轮询算法</p></blockquote><p><strong>配置负载均衡</strong></p><p><code>nginx.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream  targetserver &#123;# upstream指令可以定义一组服务器<br>server 192.168.138.101:8080;<br>server 192.168.138.101:8081;<br>&#125;<br>server &#123;<br>       listen       80;  # 监听端口<br>       server_name  localhost;   # 服务名称<br>       location / &#123;  # 匹配客户端请求url<br>       proxy_passhttp://targetserver;<br>       &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>权重的配置方式</strong></p><p><code>nginx.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream  targetserver &#123;# upstream指令可以定义一组服务器<br>server 192.168.138.101:8080 weight=10;<br>server 192.168.138.101:8081 weight=5;<br>&#125;<br>server &#123;<br>       listen       80;  # 监听端口<br>       server_name  localhost;   # 服务名称<br>       location / &#123;  # 匹配客户端请求url<br>       proxy_passhttp://targetserver;<br>       &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p><strong>导入knife4j的坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>导入配置</strong></p><p><code>WebMvcConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@EnableSwagger2</span> <span class="hljs-comment">// Swagger</span><br><span class="hljs-meta">@EnableKnife4j</span> <span class="hljs-comment">// Knife4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;<br>    <br>    ......<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">createRestApi</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 文档类型</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .select()<br>                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.itheima.reggie.controller&quot;</span>))<br>                .paths(PathSelectors.any())<br>                .build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfoBuilder</span>()<br>                .title(<span class="hljs-string">&quot;瑞吉外卖&quot;</span>)<br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                .description(<span class="hljs-string">&quot;瑞吉外卖接口文档&quot;</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>设置静态资源映射</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">registry.addResourceHandler(<span class="hljs-string">&quot;doc.html&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>);<br>registry.addResourceHandler(<span class="hljs-string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>设置<code>LoginCheckFilter</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义不需要处理的请求路径</span><br>String[] urls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>        <br>    ......<br>            <br>        <span class="hljs-string">&quot;/doc.html&quot;</span>,<br>        <span class="hljs-string">&quot;/webjars/**&quot;</span>,<br>        <span class="hljs-string">&quot;/swagger-resources&quot;</span>,<br>        <span class="hljs-string">&quot;/v2/api-docs&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="减商品"><a href="#减商品" class="headerlink" title="减商品"></a>减商品</h1>]]></content>
    
    
    <categories>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>ssm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
